{"ast":null,"code":"import { isURL } from \"../utils.js\";\nimport { ResourceTiming, PageLoadTiming, PageRenderTiming } from \"../messages/index.js\";\n\nfunction getPaintBlocks(resources) {\n  const paintBlocks = [];\n  const elements = document.getElementsByTagName('*');\n  const styleURL = /url\\((\"[^\"]*\"|'[^']*'|[^)]*)\\)/i;\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    let src = '';\n\n    if (element instanceof HTMLImageElement) {\n      src = element.currentSrc || element.src;\n    }\n\n    if (!src) {\n      const backgroundImage = getComputedStyle(element).getPropertyValue('background-image');\n\n      if (backgroundImage) {\n        const matches = styleURL.exec(backgroundImage);\n\n        if (matches !== null) {\n          src = matches[1];\n\n          if (src.startsWith('\"') || src.startsWith(\"'\")) {\n            src = src.substr(1, src.length - 2);\n          }\n        }\n      }\n    }\n\n    if (!src) continue;\n    const time = src.substr(0, 10) === 'data:image' ? 0 : resources[src];\n    if (time === undefined) continue;\n    const rect = element.getBoundingClientRect();\n    const top = Math.max(rect.top, 0);\n    const left = Math.max(rect.left, 0);\n    const bottom = Math.min(rect.bottom, window.innerHeight || document.documentElement && document.documentElement.clientHeight || 0);\n    const right = Math.min(rect.right, window.innerWidth || document.documentElement && document.documentElement.clientWidth || 0);\n    if (bottom <= top || right <= left) continue;\n    const area = (bottom - top) * (right - left);\n    paintBlocks.push({\n      time,\n      area\n    });\n  }\n\n  return paintBlocks;\n}\n\nfunction calculateSpeedIndex(firstContentfulPaint, paintBlocks) {\n  let a = Math.max(document.documentElement && document.documentElement.clientWidth || 0, window.innerWidth || 0) * Math.max(document.documentElement && document.documentElement.clientHeight || 0, window.innerHeight || 0) / 10;\n  let s = a * firstContentfulPaint;\n\n  for (let i = 0; i < paintBlocks.length; i++) {\n    const {\n      time,\n      area\n    } = paintBlocks[i];\n    a += area;\n    s += area * (time > firstContentfulPaint ? time : firstContentfulPaint);\n  }\n\n  return a === 0 ? 0 : s / a;\n}\n\nexport default function (app, opts) {\n  const options = Object.assign({\n    captureResourceTimings: true,\n    capturePageLoadTimings: true,\n    capturePageRenderTimings: true\n  }, opts);\n\n  if (!('PerformanceObserver' in window)) {\n    options.captureResourceTimings = false;\n  }\n\n  if (!options.captureResourceTimings) {\n    return;\n  } // Resources are necessary for all timings\n\n\n  const mQueue = [];\n\n  function sendOnStart(m) {\n    if (app.active()) {\n      app.send(m);\n    } else {\n      mQueue.push(m);\n    }\n  }\n\n  app.attachStartCallback(function () {\n    mQueue.forEach(m => app.send(m));\n  });\n  let resources = {};\n\n  function resourceTiming(entry) {\n    if (entry.duration < 0 || !isURL(entry.name) || app.isServiceURL(entry.name)) return;\n\n    if (resources !== null) {\n      resources[entry.name] = entry.startTime + entry.duration;\n    }\n\n    sendOnStart(new ResourceTiming(entry.startTime + performance.timing.navigationStart, entry.duration, entry.responseStart && entry.startTime ? entry.responseStart - entry.startTime : 0, entry.transferSize > entry.encodedBodySize ? entry.transferSize - entry.encodedBodySize : 0, entry.encodedBodySize || 0, entry.decodedBodySize || 0, entry.name, entry.initiatorType));\n  }\n\n  const observer = new PerformanceObserver(list => list.getEntries().forEach(resourceTiming));\n  performance.getEntriesByType('resource').forEach(resourceTiming);\n  observer.observe({\n    entryTypes: ['resource']\n  });\n  let firstPaint = 0,\n      firstContentfulPaint = 0;\n\n  if (options.capturePageLoadTimings) {\n    let pageLoadTimingSent = false;\n    app.ticker.attach(() => {\n      if (pageLoadTimingSent) {\n        return;\n      }\n\n      if (firstPaint === 0 || firstContentfulPaint === 0) {\n        performance.getEntriesByType('paint').forEach(entry => {\n          const {\n            name,\n            startTime\n          } = entry;\n\n          switch (name) {\n            case 'first-paint':\n              firstPaint = startTime;\n              break;\n\n            case 'first-contentful-paint':\n              firstContentfulPaint = startTime;\n              break;\n          }\n        });\n      }\n\n      if (performance.timing.loadEventEnd || performance.now() > 30000) {\n        pageLoadTimingSent = true;\n        const {\n          navigationStart,\n          requestStart,\n          responseStart,\n          responseEnd,\n          domContentLoadedEventStart,\n          domContentLoadedEventEnd,\n          loadEventStart,\n          loadEventEnd\n        } = performance.timing;\n        app.send(new PageLoadTiming(requestStart - navigationStart || 0, responseStart - navigationStart || 0, responseEnd - navigationStart || 0, domContentLoadedEventStart - navigationStart || 0, domContentLoadedEventEnd - navigationStart || 0, loadEventStart - navigationStart || 0, loadEventEnd - navigationStart || 0, firstPaint, firstContentfulPaint));\n      }\n    }, 30);\n  }\n\n  if (options.capturePageRenderTimings) {\n    let visuallyComplete = 0,\n        interactiveWindowStartTime = 0,\n        interactiveWindowTickTime = 0,\n        paintBlocks = null;\n    let pageRenderTimingSent = false;\n    app.ticker.attach(() => {\n      if (pageRenderTimingSent) {\n        return;\n      }\n\n      const time = performance.now();\n\n      if (resources !== null) {\n        visuallyComplete = Math.max.apply(null, Object.keys(resources).map(k => resources[k]));\n\n        if (time - visuallyComplete > 1000) {\n          paintBlocks = getPaintBlocks(resources);\n          resources = null;\n        }\n      }\n\n      if (interactiveWindowTickTime !== null) {\n        if (time - interactiveWindowTickTime > 50) {\n          interactiveWindowStartTime = time;\n        }\n\n        interactiveWindowTickTime = time - interactiveWindowStartTime > 5000 ? null : time;\n      }\n\n      if (paintBlocks !== null && interactiveWindowTickTime === null || time > 30000) {\n        pageRenderTimingSent = true;\n        resources = null;\n        const speedIndex = paintBlocks === null ? 0 : calculateSpeedIndex(firstContentfulPaint || firstPaint, paintBlocks);\n        const timeToInteractive = interactiveWindowTickTime === null ? Math.max(interactiveWindowStartTime, firstContentfulPaint, performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart || 0) : 0;\n        app.send(new PageRenderTiming(speedIndex, firstContentfulPaint > visuallyComplete ? firstContentfulPaint : visuallyComplete, timeToInteractive));\n      }\n    });\n  }\n}","map":{"version":3,"sources":["/Users/kushthakker/Downloads/imagecompare-both/node_modules/@openreplay/tracker/lib/modules/timing.js"],"names":["isURL","ResourceTiming","PageLoadTiming","PageRenderTiming","getPaintBlocks","resources","paintBlocks","elements","document","getElementsByTagName","styleURL","i","length","element","src","HTMLImageElement","currentSrc","backgroundImage","getComputedStyle","getPropertyValue","matches","exec","startsWith","substr","time","undefined","rect","getBoundingClientRect","top","Math","max","left","bottom","min","window","innerHeight","documentElement","clientHeight","right","innerWidth","clientWidth","area","push","calculateSpeedIndex","firstContentfulPaint","a","s","app","opts","options","Object","assign","captureResourceTimings","capturePageLoadTimings","capturePageRenderTimings","mQueue","sendOnStart","m","active","send","attachStartCallback","forEach","resourceTiming","entry","duration","name","isServiceURL","startTime","performance","timing","navigationStart","responseStart","transferSize","encodedBodySize","decodedBodySize","initiatorType","observer","PerformanceObserver","list","getEntries","getEntriesByType","observe","entryTypes","firstPaint","pageLoadTimingSent","ticker","attach","loadEventEnd","now","requestStart","responseEnd","domContentLoadedEventStart","domContentLoadedEventEnd","loadEventStart","visuallyComplete","interactiveWindowStartTime","interactiveWindowTickTime","pageRenderTimingSent","apply","keys","map","k","speedIndex","timeToInteractive"],"mappings":"AAAA,SAASA,KAAT,QAAsB,aAAtB;AACA,SAASC,cAAT,EAAyBC,cAAzB,EAAyCC,gBAAzC,QAAiE,sBAAjE;;AACA,SAASC,cAAT,CAAwBC,SAAxB,EAAmC;AAC/B,QAAMC,WAAW,GAAG,EAApB;AACA,QAAMC,QAAQ,GAAGC,QAAQ,CAACC,oBAAT,CAA8B,GAA9B,CAAjB;AACA,QAAMC,QAAQ,GAAG,iCAAjB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAAQ,CAACK,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACtC,UAAME,OAAO,GAAGN,QAAQ,CAACI,CAAD,CAAxB;AACA,QAAIG,GAAG,GAAG,EAAV;;AACA,QAAID,OAAO,YAAYE,gBAAvB,EAAyC;AACrCD,MAAAA,GAAG,GAAGD,OAAO,CAACG,UAAR,IAAsBH,OAAO,CAACC,GAApC;AACH;;AACD,QAAI,CAACA,GAAL,EAAU;AACN,YAAMG,eAAe,GAAGC,gBAAgB,CAACL,OAAD,CAAhB,CAA0BM,gBAA1B,CAA2C,kBAA3C,CAAxB;;AACA,UAAIF,eAAJ,EAAqB;AACjB,cAAMG,OAAO,GAAGV,QAAQ,CAACW,IAAT,CAAcJ,eAAd,CAAhB;;AACA,YAAIG,OAAO,KAAK,IAAhB,EAAsB;AAClBN,UAAAA,GAAG,GAAGM,OAAO,CAAC,CAAD,CAAb;;AACA,cAAIN,GAAG,CAACQ,UAAJ,CAAe,GAAf,KAAuBR,GAAG,CAACQ,UAAJ,CAAe,GAAf,CAA3B,EAAgD;AAC5CR,YAAAA,GAAG,GAAGA,GAAG,CAACS,MAAJ,CAAW,CAAX,EAAcT,GAAG,CAACF,MAAJ,GAAa,CAA3B,CAAN;AACH;AACJ;AACJ;AACJ;;AACD,QAAI,CAACE,GAAL,EACI;AACJ,UAAMU,IAAI,GAAGV,GAAG,CAACS,MAAJ,CAAW,CAAX,EAAc,EAAd,MAAsB,YAAtB,GAAqC,CAArC,GAAyClB,SAAS,CAACS,GAAD,CAA/D;AACA,QAAIU,IAAI,KAAKC,SAAb,EACI;AACJ,UAAMC,IAAI,GAAGb,OAAO,CAACc,qBAAR,EAAb;AACA,UAAMC,GAAG,GAAGC,IAAI,CAACC,GAAL,CAASJ,IAAI,CAACE,GAAd,EAAmB,CAAnB,CAAZ;AACA,UAAMG,IAAI,GAAGF,IAAI,CAACC,GAAL,CAASJ,IAAI,CAACK,IAAd,EAAoB,CAApB,CAAb;AACA,UAAMC,MAAM,GAAGH,IAAI,CAACI,GAAL,CAASP,IAAI,CAACM,MAAd,EAAsBE,MAAM,CAACC,WAAP,IAChC3B,QAAQ,CAAC4B,eAAT,IAA4B5B,QAAQ,CAAC4B,eAAT,CAAyBC,YADrB,IAEjC,CAFW,CAAf;AAGA,UAAMC,KAAK,GAAGT,IAAI,CAACI,GAAL,CAASP,IAAI,CAACY,KAAd,EAAqBJ,MAAM,CAACK,UAAP,IAC9B/B,QAAQ,CAAC4B,eAAT,IAA4B5B,QAAQ,CAAC4B,eAAT,CAAyBI,WADvB,IAE/B,CAFU,CAAd;AAGA,QAAIR,MAAM,IAAIJ,GAAV,IAAiBU,KAAK,IAAIP,IAA9B,EACI;AACJ,UAAMU,IAAI,GAAG,CAACT,MAAM,GAAGJ,GAAV,KAAkBU,KAAK,GAAGP,IAA1B,CAAb;AACAzB,IAAAA,WAAW,CAACoC,IAAZ,CAAiB;AAAElB,MAAAA,IAAF;AAAQiB,MAAAA;AAAR,KAAjB;AACH;;AACD,SAAOnC,WAAP;AACH;;AACD,SAASqC,mBAAT,CAA6BC,oBAA7B,EAAmDtC,WAAnD,EAAgE;AAC5D,MAAIuC,CAAC,GAAIhB,IAAI,CAACC,GAAL,CAAUtB,QAAQ,CAAC4B,eAAT,IAA4B5B,QAAQ,CAAC4B,eAAT,CAAyBI,WAAtD,IAAsE,CAA/E,EAAkFN,MAAM,CAACK,UAAP,IAAqB,CAAvG,IACLV,IAAI,CAACC,GAAL,CAAUtB,QAAQ,CAAC4B,eAAT,IAA4B5B,QAAQ,CAAC4B,eAAT,CAAyBC,YAAtD,IACL,CADJ,EACOH,MAAM,CAACC,WAAP,IAAsB,CAD7B,CADI,GAGJ,EAHJ;AAIA,MAAIW,CAAC,GAAGD,CAAC,GAAGD,oBAAZ;;AACA,OAAK,IAAIjC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,WAAW,CAACM,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AACzC,UAAM;AAAEa,MAAAA,IAAF;AAAQiB,MAAAA;AAAR,QAAiBnC,WAAW,CAACK,CAAD,CAAlC;AACAkC,IAAAA,CAAC,IAAIJ,IAAL;AACAK,IAAAA,CAAC,IAAIL,IAAI,IAAIjB,IAAI,GAAGoB,oBAAP,GAA8BpB,IAA9B,GAAqCoB,oBAAzC,CAAT;AACH;;AACD,SAAOC,CAAC,KAAK,CAAN,GAAU,CAAV,GAAcC,CAAC,GAAGD,CAAzB;AACH;;AACD,eAAe,UAAUE,GAAV,EAAeC,IAAf,EAAqB;AAChC,QAAMC,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc;AAC1BC,IAAAA,sBAAsB,EAAE,IADE;AAE1BC,IAAAA,sBAAsB,EAAE,IAFE;AAG1BC,IAAAA,wBAAwB,EAAE;AAHA,GAAd,EAIbN,IAJa,CAAhB;;AAKA,MAAI,EAAE,yBAAyBd,MAA3B,CAAJ,EAAwC;AACpCe,IAAAA,OAAO,CAACG,sBAAR,GAAiC,KAAjC;AACH;;AACD,MAAI,CAACH,OAAO,CAACG,sBAAb,EAAqC;AACjC;AACH,GAX+B,CAW9B;;;AACF,QAAMG,MAAM,GAAG,EAAf;;AACA,WAASC,WAAT,CAAqBC,CAArB,EAAwB;AACpB,QAAIV,GAAG,CAACW,MAAJ,EAAJ,EAAkB;AACdX,MAAAA,GAAG,CAACY,IAAJ,CAASF,CAAT;AACH,KAFD,MAGK;AACDF,MAAAA,MAAM,CAACb,IAAP,CAAYe,CAAZ;AACH;AACJ;;AACDV,EAAAA,GAAG,CAACa,mBAAJ,CAAwB,YAAY;AAChCL,IAAAA,MAAM,CAACM,OAAP,CAAeJ,CAAC,IAAIV,GAAG,CAACY,IAAJ,CAASF,CAAT,CAApB;AACH,GAFD;AAGA,MAAIpD,SAAS,GAAG,EAAhB;;AACA,WAASyD,cAAT,CAAwBC,KAAxB,EAA+B;AAC3B,QAAIA,KAAK,CAACC,QAAN,GAAiB,CAAjB,IAAsB,CAAChE,KAAK,CAAC+D,KAAK,CAACE,IAAP,CAA5B,IAA4ClB,GAAG,CAACmB,YAAJ,CAAiBH,KAAK,CAACE,IAAvB,CAAhD,EACI;;AACJ,QAAI5D,SAAS,KAAK,IAAlB,EAAwB;AACpBA,MAAAA,SAAS,CAAC0D,KAAK,CAACE,IAAP,CAAT,GAAwBF,KAAK,CAACI,SAAN,GAAkBJ,KAAK,CAACC,QAAhD;AACH;;AACDR,IAAAA,WAAW,CAAC,IAAIvD,cAAJ,CAAmB8D,KAAK,CAACI,SAAN,GAAkBC,WAAW,CAACC,MAAZ,CAAmBC,eAAxD,EAAyEP,KAAK,CAACC,QAA/E,EAAyFD,KAAK,CAACQ,aAAN,IAAuBR,KAAK,CAACI,SAA7B,GAC/FJ,KAAK,CAACQ,aAAN,GAAsBR,KAAK,CAACI,SADmE,GAE/F,CAFM,EAEHJ,KAAK,CAACS,YAAN,GAAqBT,KAAK,CAACU,eAA3B,GACHV,KAAK,CAACS,YAAN,GAAqBT,KAAK,CAACU,eADxB,GAEH,CAJM,EAIHV,KAAK,CAACU,eAAN,IAAyB,CAJtB,EAIyBV,KAAK,CAACW,eAAN,IAAyB,CAJlD,EAIqDX,KAAK,CAACE,IAJ3D,EAIiEF,KAAK,CAACY,aAJvE,CAAD,CAAX;AAKH;;AACD,QAAMC,QAAQ,GAAG,IAAIC,mBAAJ,CAAyBC,IAAD,IAAUA,IAAI,CAACC,UAAL,GAAkBlB,OAAlB,CAA0BC,cAA1B,CAAlC,CAAjB;AACAM,EAAAA,WAAW,CAACY,gBAAZ,CAA6B,UAA7B,EAAyCnB,OAAzC,CAAiDC,cAAjD;AACAc,EAAAA,QAAQ,CAACK,OAAT,CAAiB;AAAEC,IAAAA,UAAU,EAAE,CAAC,UAAD;AAAd,GAAjB;AACA,MAAIC,UAAU,GAAG,CAAjB;AAAA,MAAoBvC,oBAAoB,GAAG,CAA3C;;AACA,MAAIK,OAAO,CAACI,sBAAZ,EAAoC;AAChC,QAAI+B,kBAAkB,GAAG,KAAzB;AACArC,IAAAA,GAAG,CAACsC,MAAJ,CAAWC,MAAX,CAAkB,MAAM;AACpB,UAAIF,kBAAJ,EAAwB;AACpB;AACH;;AACD,UAAID,UAAU,KAAK,CAAf,IAAoBvC,oBAAoB,KAAK,CAAjD,EAAoD;AAChDwB,QAAAA,WAAW,CACNY,gBADL,CACsB,OADtB,EAEKnB,OAFL,CAEcE,KAAD,IAAW;AACpB,gBAAM;AAAEE,YAAAA,IAAF;AAAQE,YAAAA;AAAR,cAAsBJ,KAA5B;;AACA,kBAAQE,IAAR;AACI,iBAAK,aAAL;AACIkB,cAAAA,UAAU,GAAGhB,SAAb;AACA;;AACJ,iBAAK,wBAAL;AACIvB,cAAAA,oBAAoB,GAAGuB,SAAvB;AACA;AANR;AAQH,SAZD;AAaH;;AACD,UAAIC,WAAW,CAACC,MAAZ,CAAmBkB,YAAnB,IAAmCnB,WAAW,CAACoB,GAAZ,KAAoB,KAA3D,EAAkE;AAC9DJ,QAAAA,kBAAkB,GAAG,IAArB;AACA,cAAM;AAAEd,UAAAA,eAAF;AAAmBmB,UAAAA,YAAnB;AAAiClB,UAAAA,aAAjC;AAAgDmB,UAAAA,WAAhD;AAA6DC,UAAAA,0BAA7D;AAAyFC,UAAAA,wBAAzF;AAAmHC,UAAAA,cAAnH;AAAmIN,UAAAA;AAAnI,YAAqJnB,WAAW,CAACC,MAAvK;AACAtB,QAAAA,GAAG,CAACY,IAAJ,CAAS,IAAIzD,cAAJ,CAAmBuF,YAAY,GAAGnB,eAAf,IAAkC,CAArD,EAAwDC,aAAa,GAAGD,eAAhB,IAAmC,CAA3F,EAA8FoB,WAAW,GAAGpB,eAAd,IAAiC,CAA/H,EAAkIqB,0BAA0B,GAAGrB,eAA7B,IAAgD,CAAlL,EAAqLsB,wBAAwB,GAAGtB,eAA3B,IAA8C,CAAnO,EAAsOuB,cAAc,GAAGvB,eAAjB,IAAoC,CAA1Q,EAA6QiB,YAAY,GAAGjB,eAAf,IAAkC,CAA/S,EAAkTa,UAAlT,EAA8TvC,oBAA9T,CAAT;AACH;AACJ,KAxBD,EAwBG,EAxBH;AAyBH;;AACD,MAAIK,OAAO,CAACK,wBAAZ,EAAsC;AAClC,QAAIwC,gBAAgB,GAAG,CAAvB;AAAA,QAA0BC,0BAA0B,GAAG,CAAvD;AAAA,QAA0DC,yBAAyB,GAAG,CAAtF;AAAA,QAAyF1F,WAAW,GAAG,IAAvG;AACA,QAAI2F,oBAAoB,GAAG,KAA3B;AACAlD,IAAAA,GAAG,CAACsC,MAAJ,CAAWC,MAAX,CAAkB,MAAM;AACpB,UAAIW,oBAAJ,EAA0B;AACtB;AACH;;AACD,YAAMzE,IAAI,GAAG4C,WAAW,CAACoB,GAAZ,EAAb;;AACA,UAAInF,SAAS,KAAK,IAAlB,EAAwB;AACpByF,QAAAA,gBAAgB,GAAGjE,IAAI,CAACC,GAAL,CAASoE,KAAT,CAAe,IAAf,EAAqBhD,MAAM,CAACiD,IAAP,CAAY9F,SAAZ,EAAuB+F,GAAvB,CAA4BC,CAAD,IAAOhG,SAAS,CAACgG,CAAD,CAA3C,CAArB,CAAnB;;AACA,YAAI7E,IAAI,GAAGsE,gBAAP,GAA0B,IAA9B,EAAoC;AAChCxF,UAAAA,WAAW,GAAGF,cAAc,CAACC,SAAD,CAA5B;AACAA,UAAAA,SAAS,GAAG,IAAZ;AACH;AACJ;;AACD,UAAI2F,yBAAyB,KAAK,IAAlC,EAAwC;AACpC,YAAIxE,IAAI,GAAGwE,yBAAP,GAAmC,EAAvC,EAA2C;AACvCD,UAAAA,0BAA0B,GAAGvE,IAA7B;AACH;;AACDwE,QAAAA,yBAAyB,GACrBxE,IAAI,GAAGuE,0BAAP,GAAoC,IAApC,GAA2C,IAA3C,GAAkDvE,IADtD;AAEH;;AACD,UAAKlB,WAAW,KAAK,IAAhB,IAAwB0F,yBAAyB,KAAK,IAAvD,IACAxE,IAAI,GAAG,KADX,EACkB;AACdyE,QAAAA,oBAAoB,GAAG,IAAvB;AACA5F,QAAAA,SAAS,GAAG,IAAZ;AACA,cAAMiG,UAAU,GAAGhG,WAAW,KAAK,IAAhB,GACb,CADa,GAEbqC,mBAAmB,CAACC,oBAAoB,IAAIuC,UAAzB,EAAqC7E,WAArC,CAFzB;AAGA,cAAMiG,iBAAiB,GAAGP,yBAAyB,KAAK,IAA9B,GACpBnE,IAAI,CAACC,GAAL,CAASiE,0BAAT,EAAqCnD,oBAArC,EAA2DwB,WAAW,CAACC,MAAZ,CAAmBuB,wBAAnB,GACzDxB,WAAW,CAACC,MAAZ,CAAmBC,eADsC,IACnB,CADxC,CADoB,GAGpB,CAHN;AAIAvB,QAAAA,GAAG,CAACY,IAAJ,CAAS,IAAIxD,gBAAJ,CAAqBmG,UAArB,EAAiC1D,oBAAoB,GAAGkD,gBAAvB,GACpClD,oBADoC,GAEpCkD,gBAFG,EAEeS,iBAFf,CAAT;AAGH;AACJ,KAlCD;AAmCH;AACJ","sourcesContent":["import { isURL } from \"../utils.js\";\nimport { ResourceTiming, PageLoadTiming, PageRenderTiming } from \"../messages/index.js\";\nfunction getPaintBlocks(resources) {\n    const paintBlocks = [];\n    const elements = document.getElementsByTagName('*');\n    const styleURL = /url\\((\"[^\"]*\"|'[^']*'|[^)]*)\\)/i;\n    for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n        let src = '';\n        if (element instanceof HTMLImageElement) {\n            src = element.currentSrc || element.src;\n        }\n        if (!src) {\n            const backgroundImage = getComputedStyle(element).getPropertyValue('background-image');\n            if (backgroundImage) {\n                const matches = styleURL.exec(backgroundImage);\n                if (matches !== null) {\n                    src = matches[1];\n                    if (src.startsWith('\"') || src.startsWith(\"'\")) {\n                        src = src.substr(1, src.length - 2);\n                    }\n                }\n            }\n        }\n        if (!src)\n            continue;\n        const time = src.substr(0, 10) === 'data:image' ? 0 : resources[src];\n        if (time === undefined)\n            continue;\n        const rect = element.getBoundingClientRect();\n        const top = Math.max(rect.top, 0);\n        const left = Math.max(rect.left, 0);\n        const bottom = Math.min(rect.bottom, window.innerHeight ||\n            (document.documentElement && document.documentElement.clientHeight) ||\n            0);\n        const right = Math.min(rect.right, window.innerWidth ||\n            (document.documentElement && document.documentElement.clientWidth) ||\n            0);\n        if (bottom <= top || right <= left)\n            continue;\n        const area = (bottom - top) * (right - left);\n        paintBlocks.push({ time, area });\n    }\n    return paintBlocks;\n}\nfunction calculateSpeedIndex(firstContentfulPaint, paintBlocks) {\n    let a = (Math.max((document.documentElement && document.documentElement.clientWidth) || 0, window.innerWidth || 0) *\n        Math.max((document.documentElement && document.documentElement.clientHeight) ||\n            0, window.innerHeight || 0)) /\n        10;\n    let s = a * firstContentfulPaint;\n    for (let i = 0; i < paintBlocks.length; i++) {\n        const { time, area } = paintBlocks[i];\n        a += area;\n        s += area * (time > firstContentfulPaint ? time : firstContentfulPaint);\n    }\n    return a === 0 ? 0 : s / a;\n}\nexport default function (app, opts) {\n    const options = Object.assign({\n        captureResourceTimings: true,\n        capturePageLoadTimings: true,\n        capturePageRenderTimings: true,\n    }, opts);\n    if (!('PerformanceObserver' in window)) {\n        options.captureResourceTimings = false;\n    }\n    if (!options.captureResourceTimings) {\n        return;\n    } // Resources are necessary for all timings\n    const mQueue = [];\n    function sendOnStart(m) {\n        if (app.active()) {\n            app.send(m);\n        }\n        else {\n            mQueue.push(m);\n        }\n    }\n    app.attachStartCallback(function () {\n        mQueue.forEach(m => app.send(m));\n    });\n    let resources = {};\n    function resourceTiming(entry) {\n        if (entry.duration < 0 || !isURL(entry.name) || app.isServiceURL(entry.name))\n            return;\n        if (resources !== null) {\n            resources[entry.name] = entry.startTime + entry.duration;\n        }\n        sendOnStart(new ResourceTiming(entry.startTime + performance.timing.navigationStart, entry.duration, entry.responseStart && entry.startTime\n            ? entry.responseStart - entry.startTime\n            : 0, entry.transferSize > entry.encodedBodySize\n            ? entry.transferSize - entry.encodedBodySize\n            : 0, entry.encodedBodySize || 0, entry.decodedBodySize || 0, entry.name, entry.initiatorType));\n    }\n    const observer = new PerformanceObserver((list) => list.getEntries().forEach(resourceTiming));\n    performance.getEntriesByType('resource').forEach(resourceTiming);\n    observer.observe({ entryTypes: ['resource'] });\n    let firstPaint = 0, firstContentfulPaint = 0;\n    if (options.capturePageLoadTimings) {\n        let pageLoadTimingSent = false;\n        app.ticker.attach(() => {\n            if (pageLoadTimingSent) {\n                return;\n            }\n            if (firstPaint === 0 || firstContentfulPaint === 0) {\n                performance\n                    .getEntriesByType('paint')\n                    .forEach((entry) => {\n                    const { name, startTime } = entry;\n                    switch (name) {\n                        case 'first-paint':\n                            firstPaint = startTime;\n                            break;\n                        case 'first-contentful-paint':\n                            firstContentfulPaint = startTime;\n                            break;\n                    }\n                });\n            }\n            if (performance.timing.loadEventEnd || performance.now() > 30000) {\n                pageLoadTimingSent = true;\n                const { navigationStart, requestStart, responseStart, responseEnd, domContentLoadedEventStart, domContentLoadedEventEnd, loadEventStart, loadEventEnd, } = performance.timing;\n                app.send(new PageLoadTiming(requestStart - navigationStart || 0, responseStart - navigationStart || 0, responseEnd - navigationStart || 0, domContentLoadedEventStart - navigationStart || 0, domContentLoadedEventEnd - navigationStart || 0, loadEventStart - navigationStart || 0, loadEventEnd - navigationStart || 0, firstPaint, firstContentfulPaint));\n            }\n        }, 30);\n    }\n    if (options.capturePageRenderTimings) {\n        let visuallyComplete = 0, interactiveWindowStartTime = 0, interactiveWindowTickTime = 0, paintBlocks = null;\n        let pageRenderTimingSent = false;\n        app.ticker.attach(() => {\n            if (pageRenderTimingSent) {\n                return;\n            }\n            const time = performance.now();\n            if (resources !== null) {\n                visuallyComplete = Math.max.apply(null, Object.keys(resources).map((k) => resources[k]));\n                if (time - visuallyComplete > 1000) {\n                    paintBlocks = getPaintBlocks(resources);\n                    resources = null;\n                }\n            }\n            if (interactiveWindowTickTime !== null) {\n                if (time - interactiveWindowTickTime > 50) {\n                    interactiveWindowStartTime = time;\n                }\n                interactiveWindowTickTime =\n                    time - interactiveWindowStartTime > 5000 ? null : time;\n            }\n            if ((paintBlocks !== null && interactiveWindowTickTime === null) ||\n                time > 30000) {\n                pageRenderTimingSent = true;\n                resources = null;\n                const speedIndex = paintBlocks === null\n                    ? 0\n                    : calculateSpeedIndex(firstContentfulPaint || firstPaint, paintBlocks);\n                const timeToInteractive = interactiveWindowTickTime === null\n                    ? Math.max(interactiveWindowStartTime, firstContentfulPaint, performance.timing.domContentLoadedEventEnd -\n                        performance.timing.navigationStart || 0)\n                    : 0;\n                app.send(new PageRenderTiming(speedIndex, firstContentfulPaint > visuallyComplete\n                    ? firstContentfulPaint\n                    : visuallyComplete, timeToInteractive));\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}