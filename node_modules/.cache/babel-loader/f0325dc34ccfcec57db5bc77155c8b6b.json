{"ast":null,"code":"import { stars, hasOpenreplayAttribute } from \"../../utils.js\";\nimport { RemoveNodeAttribute, SetNodeAttribute, SetNodeAttributeURLBased, SetCSSDataURLBased, SetNodeData, CreateTextNode, CreateElementNode, MoveNode, RemoveNode } from \"../../messages/index.js\";\n\nfunction isSVGElement(node) {\n  return node.namespaceURI === 'http://www.w3.org/2000/svg';\n} // TODO: we need a type expert here so we won't have to ignore the lines\n// TODO: use it everywhere (static function; export from which file? <-- global Window typing required)\n\n\nexport function isInstance(node, constr) {\n  const doc = node.ownerDocument;\n\n  if (!doc) {\n    // null if Document\n    return constr.name === 'Document';\n  }\n\n  let context = // @ts-ignore (for EI, Safary)\n  doc.parentWindow || doc.defaultView; // TODO: smart global typing for Window object\n\n  while (context.parent && context.parent !== context) {\n    // @ts-ignore\n    if (node instanceof context[constr.name]) {\n      return true;\n    } // @ts-ignore\n\n\n    context = context.parent;\n  } // @ts-ignore\n\n\n  return node instanceof context[constr.name];\n}\n\nfunction isIgnored(node) {\n  if (isInstance(node, Text)) {\n    return false;\n  }\n\n  if (!isInstance(node, Element)) {\n    return true;\n  }\n\n  const tag = node.tagName.toUpperCase();\n\n  if (tag === 'LINK') {\n    const rel = node.getAttribute('rel');\n    const as = node.getAttribute('as');\n    return !((rel === null || rel === void 0 ? void 0 : rel.includes('stylesheet')) || as === \"style\" || as === \"font\");\n  }\n\n  return tag === 'SCRIPT' || tag === 'NOSCRIPT' || tag === 'META' || tag === 'TITLE' || tag === 'BASE';\n}\n\nfunction isRootNode(node) {\n  return isInstance(node, Document) || isInstance(node, ShadowRoot);\n}\n\nfunction isObservable(node) {\n  if (isRootNode(node)) {\n    return true;\n  }\n\n  return !isIgnored(node);\n}\n\nexport default class Observer {\n  constructor(app, options) {\n    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;\n    this.app = app;\n    this.context = context;\n    this.commited = [];\n    this.recents = [];\n    this.myNodes = [];\n    this.indexes = [];\n    this.attributesList = [];\n    this.textSet = new Set();\n    this.textMasked = new Set();\n    this.options = Object.assign({\n      obscureTextEmails: true,\n      obscureTextNumbers: false\n    }, options);\n    this.inUpperContext = context.parent === context;\n    this.observer = new MutationObserver(this.app.safe(mutations => {\n      for (const mutation of mutations) {\n        const target = mutation.target;\n        const type = mutation.type; // TODO TODO TODO: move to iframe_observer/remove??? (check if )\n        // Special case\n        // 'childList' on Document might happen in case of iframe. \n        // TODO: generalize as much as possible\n        // if (isInstance(target, Document) // Also ShadowRoot can be here\n        //     && type === 'childList' \n        //     //&& new Array(mutation.addedNodes).some(node => isInstance(node, HTMLHtmlElement))\n        // ) {\n        //   const parentFrame = target.defaultView?.frameElement\n        //   if (!parentFrame) { continue }\n        //   this.bindTree(target.documentElement)\n        //   const frameID = this.app.nodes.getID(parentFrame)\n        //   const docID = this.app.nodes.getID(target.documentElement)\n        //   if (frameID === undefined || docID === undefined) { continue }\n        //   this.app.send(CreateIFrameDocument(frameID, docID));\n        //   continue;\n        // }\n\n        if (!isObservable(target) || !context.document.contains(target)) {\n          continue;\n        }\n\n        if (type === 'childList') {\n          for (let i = 0; i < mutation.removedNodes.length; i++) {\n            this.bindTree(mutation.removedNodes[i]);\n          }\n\n          for (let i = 0; i < mutation.addedNodes.length; i++) {\n            this.bindTree(mutation.addedNodes[i]);\n          }\n\n          continue;\n        }\n\n        const id = this.app.nodes.getID(target);\n\n        if (id === undefined) {\n          continue;\n        }\n\n        if (id >= this.recents.length) {\n          // TODO: something more convinient\n          this.recents[id] = undefined;\n        }\n\n        if (type === 'attributes') {\n          const name = mutation.attributeName;\n\n          if (name === null) {\n            continue;\n          }\n\n          let attr = this.attributesList[id];\n\n          if (attr === undefined) {\n            this.attributesList[id] = attr = new Set();\n          }\n\n          attr.add(name);\n          continue;\n        }\n\n        if (type === 'characterData') {\n          this.textSet.add(id);\n          continue;\n        }\n      }\n\n      this.commitNodes();\n    }));\n  }\n\n  clear() {\n    this.commited.length = 0;\n    this.recents.length = 0;\n    this.indexes.length = 1;\n    this.attributesList.length = 0;\n    this.textSet.clear(); //this.textMasked.clear();\n  }\n\n  sendNodeAttribute(id, node, name, value) {\n    if (isSVGElement(node)) {\n      if (name.substr(0, 6) === 'xlink:') {\n        name = name.substr(6);\n      }\n\n      if (value === null) {\n        this.app.send(new RemoveNodeAttribute(id, name));\n      } else if (name === 'href') {\n        if (value.length > 1e5) {\n          value = '';\n        }\n\n        this.app.send(new SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));\n      } else {\n        this.app.send(new SetNodeAttribute(id, name, value));\n      }\n\n      return;\n    }\n\n    if (name === 'src' || name === 'srcset' || name === 'integrity' || name === 'crossorigin' || name === 'autocomplete' || name.substr(0, 2) === 'on') {\n      return;\n    }\n\n    if (name === 'value' && isInstance(node, HTMLInputElement) && node.type !== 'button' && node.type !== 'reset' && node.type !== 'submit') {\n      return;\n    }\n\n    if (value === null) {\n      this.app.send(new RemoveNodeAttribute(id, name));\n      return;\n    }\n\n    if (name === 'style' || name === 'href' && isInstance(node, HTMLLinkElement)) {\n      this.app.send(new SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));\n      return;\n    }\n\n    if (name === 'href' || value.length > 1e5) {\n      value = '';\n    }\n\n    this.app.send(new SetNodeAttribute(id, name, value));\n  }\n  /* TODO:  abstract sanitation */\n\n\n  getInnerTextSecure(el) {\n    const id = this.app.nodes.getID(el);\n\n    if (!id) {\n      return '';\n    }\n\n    return this.checkObscure(id, el.innerText);\n  }\n\n  checkObscure(id, data) {\n    if (this.textMasked.has(id)) {\n      return data.replace(/[^\\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]/g, '█');\n    }\n\n    if (this.options.obscureTextNumbers) {\n      data = data.replace(/\\d/g, '0');\n    }\n\n    if (this.options.obscureTextEmails) {\n      data = data.replace(/([^\\s]+)@([^\\s]+)\\.([^\\s]+)/g, function () {\n        return stars(arguments.length <= 1 ? undefined : arguments[1]) + '@' + stars(arguments.length <= 2 ? undefined : arguments[2]) + '.' + stars(arguments.length <= 3 ? undefined : arguments[3]);\n      });\n    }\n\n    return data;\n  }\n\n  sendNodeData(id, parentElement, data) {\n    if (isInstance(parentElement, HTMLStyleElement) || isInstance(parentElement, SVGStyleElement)) {\n      this.app.send(new SetCSSDataURLBased(id, data, this.app.getBaseHref()));\n      return;\n    }\n\n    data = this.checkObscure(id, data);\n    this.app.send(new SetNodeData(id, data));\n  }\n  /* end TODO:  abstract sanitation */\n\n\n  bindNode(node) {\n    const r = this.app.nodes.registerNode(node);\n    const id = r[0];\n    this.recents[id] = r[1] || this.recents[id] || false;\n    this.myNodes[id] = true;\n  }\n\n  bindTree(node) {\n    if (!isObservable(node)) {\n      return;\n    }\n\n    this.bindNode(node);\n    const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {\n      acceptNode: node => isIgnored(node) || this.app.nodes.getID(node) !== undefined ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT\n    }, // @ts-ignore\n    false);\n\n    while (walker.nextNode()) {\n      this.bindNode(walker.currentNode);\n    }\n  }\n\n  unbindNode(node) {\n    const id = this.app.nodes.unregisterNode(node);\n\n    if (id !== undefined && this.recents[id] === false) {\n      this.app.send(new RemoveNode(id));\n    }\n  }\n\n  _commitNode(id, node) {\n    if (isRootNode(node)) {\n      return true;\n    }\n\n    const parent = node.parentNode;\n    let parentID; // Disable parent check for the upper context HTMLHtmlElement, because it is root there... (before)\n    // TODO: get rid of \"special\" cases (there is an issue with CreateDocument altered behaviour though)\n    // TODO: Clean the logic (though now it workd fine) \n\n    if (!isInstance(node, HTMLHtmlElement) || !this.inUpperContext) {\n      if (parent === null) {\n        this.unbindNode(node);\n        return false;\n      }\n\n      parentID = this.app.nodes.getID(parent);\n\n      if (parentID === undefined) {\n        this.unbindNode(node);\n        return false;\n      }\n\n      if (!this.commitNode(parentID)) {\n        this.unbindNode(node);\n        return false;\n      }\n\n      if (this.textMasked.has(parentID) || isInstance(node, Element) && hasOpenreplayAttribute(node, 'masked')) {\n        this.textMasked.add(id);\n      }\n    }\n\n    let sibling = node.previousSibling;\n\n    while (sibling !== null) {\n      const siblingID = this.app.nodes.getID(sibling);\n\n      if (siblingID !== undefined) {\n        this.commitNode(siblingID);\n        this.indexes[id] = this.indexes[siblingID] + 1;\n        break;\n      }\n\n      sibling = sibling.previousSibling;\n    }\n\n    if (sibling === null) {\n      this.indexes[id] = 0; //\n    }\n\n    const isNew = this.recents[id];\n    const index = this.indexes[id];\n\n    if (index === undefined) {\n      throw 'commitNode: missing node index';\n    }\n\n    if (isNew === true) {\n      if (isInstance(node, Element)) {\n        if (parentID !== undefined) {\n          this.app.send(new CreateElementNode(id, parentID, index, node.tagName, isSVGElement(node)));\n        }\n\n        for (let i = 0; i < node.attributes.length; i++) {\n          const attr = node.attributes[i];\n          this.sendNodeAttribute(id, node, attr.nodeName, attr.value);\n        }\n      } else if (isInstance(node, Text)) {\n        // for text node id != 0, hence parentID !== undefined and parent is Element\n        this.app.send(new CreateTextNode(id, parentID, index));\n        this.sendNodeData(id, parent, node.data);\n      }\n\n      return true;\n    }\n\n    if (isNew === false && parentID !== undefined) {\n      this.app.send(new MoveNode(id, parentID, index));\n    }\n\n    const attr = this.attributesList[id];\n\n    if (attr !== undefined) {\n      if (!isInstance(node, Element)) {\n        throw 'commitNode: node is not an element';\n      }\n\n      for (const name of attr) {\n        this.sendNodeAttribute(id, node, name, node.getAttribute(name));\n      }\n    }\n\n    if (this.textSet.has(id)) {\n      if (!isInstance(node, Text)) {\n        throw 'commitNode: node is not a text';\n      } // for text node id != 0, hence parent is Element\n\n\n      this.sendNodeData(id, parent, node.data);\n    }\n\n    return true;\n  }\n\n  commitNode(id) {\n    const node = this.app.nodes.getNode(id);\n\n    if (node === undefined) {\n      return false;\n    }\n\n    const cmt = this.commited[id];\n\n    if (cmt !== undefined) {\n      return cmt;\n    }\n\n    return this.commited[id] = this._commitNode(id, node);\n  }\n\n  commitNodes() {\n    let node;\n\n    for (let id = 0; id < this.recents.length; id++) {\n      // TODO: make things/logic nice here.\n      // commit required in any case if recents[id] true or false (in case of unbinding).\n      // ???!?!?R@TW:$HKJ$WLKn\n      if (!this.myNodes[id]) {\n        continue;\n      }\n\n      this.commitNode(id);\n\n      if (this.recents[id] === true && (node = this.app.nodes.getNode(id))) {\n        this.app.nodes.callNodeCallbacks(node);\n      }\n    }\n\n    this.clear();\n  } // ISSSUE\n\n\n  observeRoot(node, beforeCommit) {\n    let nodeToBind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node;\n    this.observer.observe(node, {\n      childList: true,\n      attributes: true,\n      characterData: true,\n      subtree: true,\n      attributeOldValue: false,\n      characterDataOldValue: false\n    });\n    this.bindTree(nodeToBind);\n    beforeCommit(this.app.nodes.getID(node));\n    this.commitNodes();\n  }\n\n  disconnect() {\n    this.observer.disconnect();\n    this.clear(); // to sanitizer\n\n    this.textMasked.clear();\n    this.myNodes.length = 0;\n  }\n\n}","map":{"version":3,"sources":["/Users/kushthakker/Downloads/imagecompare-both/node_modules/@openreplay/tracker/lib/app/observer/observer.js"],"names":["stars","hasOpenreplayAttribute","RemoveNodeAttribute","SetNodeAttribute","SetNodeAttributeURLBased","SetCSSDataURLBased","SetNodeData","CreateTextNode","CreateElementNode","MoveNode","RemoveNode","isSVGElement","node","namespaceURI","isInstance","constr","doc","ownerDocument","name","context","parentWindow","defaultView","parent","isIgnored","Text","Element","tag","tagName","toUpperCase","rel","getAttribute","as","includes","isRootNode","Document","ShadowRoot","isObservable","Observer","constructor","app","options","window","commited","recents","myNodes","indexes","attributesList","textSet","Set","textMasked","Object","assign","obscureTextEmails","obscureTextNumbers","inUpperContext","observer","MutationObserver","safe","mutations","mutation","target","type","document","contains","i","removedNodes","length","bindTree","addedNodes","id","nodes","getID","undefined","attributeName","attr","add","commitNodes","clear","sendNodeAttribute","value","substr","send","getBaseHref","HTMLInputElement","HTMLLinkElement","getInnerTextSecure","el","checkObscure","innerText","data","has","replace","sendNodeData","parentElement","HTMLStyleElement","SVGStyleElement","bindNode","r","registerNode","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","SHOW_TEXT","acceptNode","FILTER_REJECT","FILTER_ACCEPT","nextNode","currentNode","unbindNode","unregisterNode","_commitNode","parentNode","parentID","HTMLHtmlElement","commitNode","sibling","previousSibling","siblingID","isNew","index","attributes","nodeName","getNode","cmt","callNodeCallbacks","observeRoot","beforeCommit","nodeToBind","observe","childList","characterData","subtree","attributeOldValue","characterDataOldValue","disconnect"],"mappings":"AAAA,SAASA,KAAT,EAAgBC,sBAAhB,QAA8C,gBAA9C;AACA,SAASC,mBAAT,EAA8BC,gBAA9B,EAAgDC,wBAAhD,EAA0EC,kBAA1E,EAA8FC,WAA9F,EAA2GC,cAA3G,EAA2HC,iBAA3H,EAA8IC,QAA9I,EAAwJC,UAAxJ,QAA2K,yBAA3K;;AACA,SAASC,YAAT,CAAsBC,IAAtB,EAA4B;AACxB,SAAOA,IAAI,CAACC,YAAL,KAAsB,4BAA7B;AACH,C,CACD;AACA;;;AACA,OAAO,SAASC,UAAT,CAAoBF,IAApB,EAA0BG,MAA1B,EAAkC;AACrC,QAAMC,GAAG,GAAGJ,IAAI,CAACK,aAAjB;;AACA,MAAI,CAACD,GAAL,EAAU;AAAE;AACR,WAAOD,MAAM,CAACG,IAAP,KAAgB,UAAvB;AACH;;AACD,MAAIC,OAAO,GACX;AACAH,EAAAA,GAAG,CAACI,YAAJ,IACIJ,GAAG,CAACK,WAHR,CALqC,CAQhB;;AACrB,SAAOF,OAAO,CAACG,MAAR,IAAkBH,OAAO,CAACG,MAAR,KAAmBH,OAA5C,EAAqD;AACjD;AACA,QAAIP,IAAI,YAAYO,OAAO,CAACJ,MAAM,CAACG,IAAR,CAA3B,EAA0C;AACtC,aAAO,IAAP;AACH,KAJgD,CAKjD;;;AACAC,IAAAA,OAAO,GAAGA,OAAO,CAACG,MAAlB;AACH,GAhBoC,CAiBrC;;;AACA,SAAOV,IAAI,YAAYO,OAAO,CAACJ,MAAM,CAACG,IAAR,CAA9B;AACH;;AACD,SAASK,SAAT,CAAmBX,IAAnB,EAAyB;AACrB,MAAIE,UAAU,CAACF,IAAD,EAAOY,IAAP,CAAd,EAA4B;AACxB,WAAO,KAAP;AACH;;AACD,MAAI,CAACV,UAAU,CAACF,IAAD,EAAOa,OAAP,CAAf,EAAgC;AAC5B,WAAO,IAAP;AACH;;AACD,QAAMC,GAAG,GAAGd,IAAI,CAACe,OAAL,CAAaC,WAAb,EAAZ;;AACA,MAAIF,GAAG,KAAK,MAAZ,EAAoB;AAChB,UAAMG,GAAG,GAAGjB,IAAI,CAACkB,YAAL,CAAkB,KAAlB,CAAZ;AACA,UAAMC,EAAE,GAAGnB,IAAI,CAACkB,YAAL,CAAkB,IAAlB,CAAX;AACA,WAAO,EAAE,CAACD,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAK,KAAK,CAA7B,GAAiC,KAAK,CAAtC,GAA0CA,GAAG,CAACG,QAAJ,CAAa,YAAb,CAA3C,KAA0ED,EAAE,KAAK,OAAjF,IAA4FA,EAAE,KAAK,MAArG,CAAP;AACH;;AACD,SAAQL,GAAG,KAAK,QAAR,IACJA,GAAG,KAAK,UADJ,IAEJA,GAAG,KAAK,MAFJ,IAGJA,GAAG,KAAK,OAHJ,IAIJA,GAAG,KAAK,MAJZ;AAKH;;AACD,SAASO,UAAT,CAAoBrB,IAApB,EAA0B;AACtB,SAAOE,UAAU,CAACF,IAAD,EAAOsB,QAAP,CAAV,IAA8BpB,UAAU,CAACF,IAAD,EAAOuB,UAAP,CAA/C;AACH;;AACD,SAASC,YAAT,CAAsBxB,IAAtB,EAA4B;AACxB,MAAIqB,UAAU,CAACrB,IAAD,CAAd,EAAsB;AAClB,WAAO,IAAP;AACH;;AACD,SAAO,CAACW,SAAS,CAACX,IAAD,CAAjB;AACH;;AACD,eAAe,MAAMyB,QAAN,CAAe;AAC1BC,EAAAA,WAAW,CAACC,GAAD,EAAMC,OAAN,EAAiC;AAAA,QAAlBrB,OAAkB,uEAARsB,MAAQ;AACxC,SAAKF,GAAL,GAAWA,GAAX;AACA,SAAKpB,OAAL,GAAeA,OAAf;AACA,SAAKuB,QAAL,GAAgB,EAAhB;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,OAAL,GAAe,IAAIC,GAAJ,EAAf;AACA,SAAKC,UAAL,GAAkB,IAAID,GAAJ,EAAlB;AACA,SAAKR,OAAL,GAAeU,MAAM,CAACC,MAAP,CAAc;AACzBC,MAAAA,iBAAiB,EAAE,IADM;AAEzBC,MAAAA,kBAAkB,EAAE;AAFK,KAAd,EAGZb,OAHY,CAAf;AAIA,SAAKc,cAAL,GAAsBnC,OAAO,CAACG,MAAR,KAAmBH,OAAzC;AACA,SAAKoC,QAAL,GAAgB,IAAIC,gBAAJ,CAAqB,KAAKjB,GAAL,CAASkB,IAAT,CAAeC,SAAD,IAAe;AAC9D,WAAK,MAAMC,QAAX,IAAuBD,SAAvB,EAAkC;AAC9B,cAAME,MAAM,GAAGD,QAAQ,CAACC,MAAxB;AACA,cAAMC,IAAI,GAAGF,QAAQ,CAACE,IAAtB,CAF8B,CAG9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAI,CAACzB,YAAY,CAACwB,MAAD,CAAb,IAAyB,CAACzC,OAAO,CAAC2C,QAAR,CAAiBC,QAAjB,CAA0BH,MAA1B,CAA9B,EAAiE;AAC7D;AACH;;AACD,YAAIC,IAAI,KAAK,WAAb,EAA0B;AACtB,eAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,QAAQ,CAACM,YAAT,CAAsBC,MAA1C,EAAkDF,CAAC,EAAnD,EAAuD;AACnD,iBAAKG,QAAL,CAAcR,QAAQ,CAACM,YAAT,CAAsBD,CAAtB,CAAd;AACH;;AACD,eAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,QAAQ,CAACS,UAAT,CAAoBF,MAAxC,EAAgDF,CAAC,EAAjD,EAAqD;AACjD,iBAAKG,QAAL,CAAcR,QAAQ,CAACS,UAAT,CAAoBJ,CAApB,CAAd;AACH;;AACD;AACH;;AACD,cAAMK,EAAE,GAAG,KAAK9B,GAAL,CAAS+B,KAAT,CAAeC,KAAf,CAAqBX,MAArB,CAAX;;AACA,YAAIS,EAAE,KAAKG,SAAX,EAAsB;AAClB;AACH;;AACD,YAAIH,EAAE,IAAI,KAAK1B,OAAL,CAAauB,MAAvB,EAA+B;AAAE;AAC7B,eAAKvB,OAAL,CAAa0B,EAAb,IAAmBG,SAAnB;AACH;;AACD,YAAIX,IAAI,KAAK,YAAb,EAA2B;AACvB,gBAAM3C,IAAI,GAAGyC,QAAQ,CAACc,aAAtB;;AACA,cAAIvD,IAAI,KAAK,IAAb,EAAmB;AACf;AACH;;AACD,cAAIwD,IAAI,GAAG,KAAK5B,cAAL,CAAoBuB,EAApB,CAAX;;AACA,cAAIK,IAAI,KAAKF,SAAb,EAAwB;AACpB,iBAAK1B,cAAL,CAAoBuB,EAApB,IAA0BK,IAAI,GAAG,IAAI1B,GAAJ,EAAjC;AACH;;AACD0B,UAAAA,IAAI,CAACC,GAAL,CAASzD,IAAT;AACA;AACH;;AACD,YAAI2C,IAAI,KAAK,eAAb,EAA8B;AAC1B,eAAKd,OAAL,CAAa4B,GAAb,CAAiBN,EAAjB;AACA;AACH;AACJ;;AACD,WAAKO,WAAL;AACH,KA1DoC,CAArB,CAAhB;AA2DH;;AACDC,EAAAA,KAAK,GAAG;AACJ,SAAKnC,QAAL,CAAcwB,MAAd,GAAuB,CAAvB;AACA,SAAKvB,OAAL,CAAauB,MAAb,GAAsB,CAAtB;AACA,SAAKrB,OAAL,CAAaqB,MAAb,GAAsB,CAAtB;AACA,SAAKpB,cAAL,CAAoBoB,MAApB,GAA6B,CAA7B;AACA,SAAKnB,OAAL,CAAa8B,KAAb,GALI,CAMJ;AACH;;AACDC,EAAAA,iBAAiB,CAACT,EAAD,EAAKzD,IAAL,EAAWM,IAAX,EAAiB6D,KAAjB,EAAwB;AACrC,QAAIpE,YAAY,CAACC,IAAD,CAAhB,EAAwB;AACpB,UAAIM,IAAI,CAAC8D,MAAL,CAAY,CAAZ,EAAe,CAAf,MAAsB,QAA1B,EAAoC;AAChC9D,QAAAA,IAAI,GAAGA,IAAI,CAAC8D,MAAL,CAAY,CAAZ,CAAP;AACH;;AACD,UAAID,KAAK,KAAK,IAAd,EAAoB;AAChB,aAAKxC,GAAL,CAAS0C,IAAT,CAAc,IAAI/E,mBAAJ,CAAwBmE,EAAxB,EAA4BnD,IAA5B,CAAd;AACH,OAFD,MAGK,IAAIA,IAAI,KAAK,MAAb,EAAqB;AACtB,YAAI6D,KAAK,CAACb,MAAN,GAAe,GAAnB,EAAwB;AACpBa,UAAAA,KAAK,GAAG,EAAR;AACH;;AACD,aAAKxC,GAAL,CAAS0C,IAAT,CAAc,IAAI7E,wBAAJ,CAA6BiE,EAA7B,EAAiCnD,IAAjC,EAAuC6D,KAAvC,EAA8C,KAAKxC,GAAL,CAAS2C,WAAT,EAA9C,CAAd;AACH,OALI,MAMA;AACD,aAAK3C,GAAL,CAAS0C,IAAT,CAAc,IAAI9E,gBAAJ,CAAqBkE,EAArB,EAAyBnD,IAAzB,EAA+B6D,KAA/B,CAAd;AACH;;AACD;AACH;;AACD,QAAI7D,IAAI,KAAK,KAAT,IACAA,IAAI,KAAK,QADT,IAEAA,IAAI,KAAK,WAFT,IAGAA,IAAI,KAAK,aAHT,IAIAA,IAAI,KAAK,cAJT,IAKAA,IAAI,CAAC8D,MAAL,CAAY,CAAZ,EAAe,CAAf,MAAsB,IAL1B,EAKgC;AAC5B;AACH;;AACD,QAAI9D,IAAI,KAAK,OAAT,IACAJ,UAAU,CAACF,IAAD,EAAOuE,gBAAP,CADV,IAEAvE,IAAI,CAACiD,IAAL,KAAc,QAFd,IAGAjD,IAAI,CAACiD,IAAL,KAAc,OAHd,IAIAjD,IAAI,CAACiD,IAAL,KAAc,QAJlB,EAI4B;AACxB;AACH;;AACD,QAAIkB,KAAK,KAAK,IAAd,EAAoB;AAChB,WAAKxC,GAAL,CAAS0C,IAAT,CAAc,IAAI/E,mBAAJ,CAAwBmE,EAAxB,EAA4BnD,IAA5B,CAAd;AACA;AACH;;AACD,QAAIA,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,MAAT,IAAmBJ,UAAU,CAACF,IAAD,EAAOwE,eAAP,CAArD,EAA8E;AAC1E,WAAK7C,GAAL,CAAS0C,IAAT,CAAc,IAAI7E,wBAAJ,CAA6BiE,EAA7B,EAAiCnD,IAAjC,EAAuC6D,KAAvC,EAA8C,KAAKxC,GAAL,CAAS2C,WAAT,EAA9C,CAAd;AACA;AACH;;AACD,QAAIhE,IAAI,KAAK,MAAT,IAAmB6D,KAAK,CAACb,MAAN,GAAe,GAAtC,EAA2C;AACvCa,MAAAA,KAAK,GAAG,EAAR;AACH;;AACD,SAAKxC,GAAL,CAAS0C,IAAT,CAAc,IAAI9E,gBAAJ,CAAqBkE,EAArB,EAAyBnD,IAAzB,EAA+B6D,KAA/B,CAAd;AACH;AACD;;;AACAM,EAAAA,kBAAkB,CAACC,EAAD,EAAK;AACnB,UAAMjB,EAAE,GAAG,KAAK9B,GAAL,CAAS+B,KAAT,CAAeC,KAAf,CAAqBe,EAArB,CAAX;;AACA,QAAI,CAACjB,EAAL,EAAS;AACL,aAAO,EAAP;AACH;;AACD,WAAO,KAAKkB,YAAL,CAAkBlB,EAAlB,EAAsBiB,EAAE,CAACE,SAAzB,CAAP;AACH;;AACDD,EAAAA,YAAY,CAAClB,EAAD,EAAKoB,IAAL,EAAW;AACnB,QAAI,KAAKxC,UAAL,CAAgByC,GAAhB,CAAoBrB,EAApB,CAAJ,EAA6B;AACzB,aAAOoB,IAAI,CAACE,OAAL,CAAa,6EAAb,EAA4F,GAA5F,CAAP;AACH;;AACD,QAAI,KAAKnD,OAAL,CAAaa,kBAAjB,EAAqC;AACjCoC,MAAAA,IAAI,GAAGA,IAAI,CAACE,OAAL,CAAa,KAAb,EAAoB,GAApB,CAAP;AACH;;AACD,QAAI,KAAKnD,OAAL,CAAaY,iBAAjB,EAAoC;AAChCqC,MAAAA,IAAI,GAAGA,IAAI,CAACE,OAAL,CAAa,8BAAb,EAA6C;AAAA,eAAU3F,KAAK,kDAAL,GAAc,GAAd,GAAoBA,KAAK,kDAAzB,GAAkC,GAAlC,GAAwCA,KAAK,kDAAvD;AAAA,OAA7C,CAAP;AACH;;AACD,WAAOyF,IAAP;AACH;;AACDG,EAAAA,YAAY,CAACvB,EAAD,EAAKwB,aAAL,EAAoBJ,IAApB,EAA0B;AAClC,QAAI3E,UAAU,CAAC+E,aAAD,EAAgBC,gBAAhB,CAAV,IAA+ChF,UAAU,CAAC+E,aAAD,EAAgBE,eAAhB,CAA7D,EAA+F;AAC3F,WAAKxD,GAAL,CAAS0C,IAAT,CAAc,IAAI5E,kBAAJ,CAAuBgE,EAAvB,EAA2BoB,IAA3B,EAAiC,KAAKlD,GAAL,CAAS2C,WAAT,EAAjC,CAAd;AACA;AACH;;AACDO,IAAAA,IAAI,GAAG,KAAKF,YAAL,CAAkBlB,EAAlB,EAAsBoB,IAAtB,CAAP;AACA,SAAKlD,GAAL,CAAS0C,IAAT,CAAc,IAAI3E,WAAJ,CAAgB+D,EAAhB,EAAoBoB,IAApB,CAAd;AACH;AACD;;;AACAO,EAAAA,QAAQ,CAACpF,IAAD,EAAO;AACX,UAAMqF,CAAC,GAAG,KAAK1D,GAAL,CAAS+B,KAAT,CAAe4B,YAAf,CAA4BtF,IAA5B,CAAV;AACA,UAAMyD,EAAE,GAAG4B,CAAC,CAAC,CAAD,CAAZ;AACA,SAAKtD,OAAL,CAAa0B,EAAb,IAAmB4B,CAAC,CAAC,CAAD,CAAD,IAAQ,KAAKtD,OAAL,CAAa0B,EAAb,CAAR,IAA4B,KAA/C;AACA,SAAKzB,OAAL,CAAayB,EAAb,IAAmB,IAAnB;AACH;;AACDF,EAAAA,QAAQ,CAACvD,IAAD,EAAO;AACX,QAAI,CAACwB,YAAY,CAACxB,IAAD,CAAjB,EAAyB;AACrB;AACH;;AACD,SAAKoF,QAAL,CAAcpF,IAAd;AACA,UAAMuF,MAAM,GAAGrC,QAAQ,CAACsC,gBAAT,CAA0BxF,IAA1B,EAAgCyF,UAAU,CAACC,YAAX,GAA0BD,UAAU,CAACE,SAArE,EAAgF;AAC3FC,MAAAA,UAAU,EAAG5F,IAAD,IAAUW,SAAS,CAACX,IAAD,CAAT,IAAmB,KAAK2B,GAAL,CAAS+B,KAAT,CAAeC,KAAf,CAAqB3D,IAArB,MAA+B4D,SAAlD,GAChB6B,UAAU,CAACI,aADK,GAEhBJ,UAAU,CAACK;AAH0E,KAAhF,EAKf;AACA,SANe,CAAf;;AAOA,WAAOP,MAAM,CAACQ,QAAP,EAAP,EAA0B;AACtB,WAAKX,QAAL,CAAcG,MAAM,CAACS,WAArB;AACH;AACJ;;AACDC,EAAAA,UAAU,CAACjG,IAAD,EAAO;AACb,UAAMyD,EAAE,GAAG,KAAK9B,GAAL,CAAS+B,KAAT,CAAewC,cAAf,CAA8BlG,IAA9B,CAAX;;AACA,QAAIyD,EAAE,KAAKG,SAAP,IAAoB,KAAK7B,OAAL,CAAa0B,EAAb,MAAqB,KAA7C,EAAoD;AAChD,WAAK9B,GAAL,CAAS0C,IAAT,CAAc,IAAIvE,UAAJ,CAAe2D,EAAf,CAAd;AACH;AACJ;;AACD0C,EAAAA,WAAW,CAAC1C,EAAD,EAAKzD,IAAL,EAAW;AAClB,QAAIqB,UAAU,CAACrB,IAAD,CAAd,EAAsB;AAClB,aAAO,IAAP;AACH;;AACD,UAAMU,MAAM,GAAGV,IAAI,CAACoG,UAApB;AACA,QAAIC,QAAJ,CALkB,CAMlB;AACA;AACA;;AACA,QAAI,CAACnG,UAAU,CAACF,IAAD,EAAOsG,eAAP,CAAX,IAAsC,CAAC,KAAK5D,cAAhD,EAAgE;AAC5D,UAAIhC,MAAM,KAAK,IAAf,EAAqB;AACjB,aAAKuF,UAAL,CAAgBjG,IAAhB;AACA,eAAO,KAAP;AACH;;AACDqG,MAAAA,QAAQ,GAAG,KAAK1E,GAAL,CAAS+B,KAAT,CAAeC,KAAf,CAAqBjD,MAArB,CAAX;;AACA,UAAI2F,QAAQ,KAAKzC,SAAjB,EAA4B;AACxB,aAAKqC,UAAL,CAAgBjG,IAAhB;AACA,eAAO,KAAP;AACH;;AACD,UAAI,CAAC,KAAKuG,UAAL,CAAgBF,QAAhB,CAAL,EAAgC;AAC5B,aAAKJ,UAAL,CAAgBjG,IAAhB;AACA,eAAO,KAAP;AACH;;AACD,UAAI,KAAKqC,UAAL,CAAgByC,GAAhB,CAAoBuB,QAApB,KACCnG,UAAU,CAACF,IAAD,EAAOa,OAAP,CAAV,IAA6BxB,sBAAsB,CAACW,IAAD,EAAO,QAAP,CADxD,EAC2E;AACvE,aAAKqC,UAAL,CAAgB0B,GAAhB,CAAoBN,EAApB;AACH;AACJ;;AACD,QAAI+C,OAAO,GAAGxG,IAAI,CAACyG,eAAnB;;AACA,WAAOD,OAAO,KAAK,IAAnB,EAAyB;AACrB,YAAME,SAAS,GAAG,KAAK/E,GAAL,CAAS+B,KAAT,CAAeC,KAAf,CAAqB6C,OAArB,CAAlB;;AACA,UAAIE,SAAS,KAAK9C,SAAlB,EAA6B;AACzB,aAAK2C,UAAL,CAAgBG,SAAhB;AACA,aAAKzE,OAAL,CAAawB,EAAb,IAAmB,KAAKxB,OAAL,CAAayE,SAAb,IAA0B,CAA7C;AACA;AACH;;AACDF,MAAAA,OAAO,GAAGA,OAAO,CAACC,eAAlB;AACH;;AACD,QAAID,OAAO,KAAK,IAAhB,EAAsB;AAClB,WAAKvE,OAAL,CAAawB,EAAb,IAAmB,CAAnB,CADkB,CACI;AACzB;;AACD,UAAMkD,KAAK,GAAG,KAAK5E,OAAL,CAAa0B,EAAb,CAAd;AACA,UAAMmD,KAAK,GAAG,KAAK3E,OAAL,CAAawB,EAAb,CAAd;;AACA,QAAImD,KAAK,KAAKhD,SAAd,EAAyB;AACrB,YAAM,gCAAN;AACH;;AACD,QAAI+C,KAAK,KAAK,IAAd,EAAoB;AAChB,UAAIzG,UAAU,CAACF,IAAD,EAAOa,OAAP,CAAd,EAA+B;AAC3B,YAAIwF,QAAQ,KAAKzC,SAAjB,EAA4B;AACxB,eAAKjC,GAAL,CAAS0C,IAAT,CAAc,IAAIzE,iBAAJ,CAAsB6D,EAAtB,EAA0B4C,QAA1B,EAAoCO,KAApC,EAA2C5G,IAAI,CAACe,OAAhD,EAAyDhB,YAAY,CAACC,IAAD,CAArE,CAAd;AACH;;AACD,aAAK,IAAIoD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpD,IAAI,CAAC6G,UAAL,CAAgBvD,MAApC,EAA4CF,CAAC,EAA7C,EAAiD;AAC7C,gBAAMU,IAAI,GAAG9D,IAAI,CAAC6G,UAAL,CAAgBzD,CAAhB,CAAb;AACA,eAAKc,iBAAL,CAAuBT,EAAvB,EAA2BzD,IAA3B,EAAiC8D,IAAI,CAACgD,QAAtC,EAAgDhD,IAAI,CAACK,KAArD;AACH;AACJ,OARD,MASK,IAAIjE,UAAU,CAACF,IAAD,EAAOY,IAAP,CAAd,EAA4B;AAC7B;AACA,aAAKe,GAAL,CAAS0C,IAAT,CAAc,IAAI1E,cAAJ,CAAmB8D,EAAnB,EAAuB4C,QAAvB,EAAiCO,KAAjC,CAAd;AACA,aAAK5B,YAAL,CAAkBvB,EAAlB,EAAsB/C,MAAtB,EAA8BV,IAAI,CAAC6E,IAAnC;AACH;;AACD,aAAO,IAAP;AACH;;AACD,QAAI8B,KAAK,KAAK,KAAV,IAAmBN,QAAQ,KAAKzC,SAApC,EAA+C;AAC3C,WAAKjC,GAAL,CAAS0C,IAAT,CAAc,IAAIxE,QAAJ,CAAa4D,EAAb,EAAiB4C,QAAjB,EAA2BO,KAA3B,CAAd;AACH;;AACD,UAAM9C,IAAI,GAAG,KAAK5B,cAAL,CAAoBuB,EAApB,CAAb;;AACA,QAAIK,IAAI,KAAKF,SAAb,EAAwB;AACpB,UAAI,CAAC1D,UAAU,CAACF,IAAD,EAAOa,OAAP,CAAf,EAAgC;AAC5B,cAAM,oCAAN;AACH;;AACD,WAAK,MAAMP,IAAX,IAAmBwD,IAAnB,EAAyB;AACrB,aAAKI,iBAAL,CAAuBT,EAAvB,EAA2BzD,IAA3B,EAAiCM,IAAjC,EAAuCN,IAAI,CAACkB,YAAL,CAAkBZ,IAAlB,CAAvC;AACH;AACJ;;AACD,QAAI,KAAK6B,OAAL,CAAa2C,GAAb,CAAiBrB,EAAjB,CAAJ,EAA0B;AACtB,UAAI,CAACvD,UAAU,CAACF,IAAD,EAAOY,IAAP,CAAf,EAA6B;AACzB,cAAM,gCAAN;AACH,OAHqB,CAItB;;;AACA,WAAKoE,YAAL,CAAkBvB,EAAlB,EAAsB/C,MAAtB,EAA8BV,IAAI,CAAC6E,IAAnC;AACH;;AACD,WAAO,IAAP;AACH;;AACD0B,EAAAA,UAAU,CAAC9C,EAAD,EAAK;AACX,UAAMzD,IAAI,GAAG,KAAK2B,GAAL,CAAS+B,KAAT,CAAeqD,OAAf,CAAuBtD,EAAvB,CAAb;;AACA,QAAIzD,IAAI,KAAK4D,SAAb,EAAwB;AACpB,aAAO,KAAP;AACH;;AACD,UAAMoD,GAAG,GAAG,KAAKlF,QAAL,CAAc2B,EAAd,CAAZ;;AACA,QAAIuD,GAAG,KAAKpD,SAAZ,EAAuB;AACnB,aAAOoD,GAAP;AACH;;AACD,WAAQ,KAAKlF,QAAL,CAAc2B,EAAd,IAAoB,KAAK0C,WAAL,CAAiB1C,EAAjB,EAAqBzD,IAArB,CAA5B;AACH;;AACDgE,EAAAA,WAAW,GAAG;AACV,QAAIhE,IAAJ;;AACA,SAAK,IAAIyD,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG,KAAK1B,OAAL,CAAauB,MAAnC,EAA2CG,EAAE,EAA7C,EAAiD;AAC7C;AACA;AACA;AACA,UAAI,CAAC,KAAKzB,OAAL,CAAayB,EAAb,CAAL,EAAuB;AACnB;AACH;;AACD,WAAK8C,UAAL,CAAgB9C,EAAhB;;AACA,UAAI,KAAK1B,OAAL,CAAa0B,EAAb,MAAqB,IAArB,KAA8BzD,IAAI,GAAG,KAAK2B,GAAL,CAAS+B,KAAT,CAAeqD,OAAf,CAAuBtD,EAAvB,CAArC,CAAJ,EAAsE;AAClE,aAAK9B,GAAL,CAAS+B,KAAT,CAAeuD,iBAAf,CAAiCjH,IAAjC;AACH;AACJ;;AACD,SAAKiE,KAAL;AACH,GA1SyB,CA2S1B;;;AACAiD,EAAAA,WAAW,CAAClH,IAAD,EAAOmH,YAAP,EAAwC;AAAA,QAAnBC,UAAmB,uEAANpH,IAAM;AAC/C,SAAK2C,QAAL,CAAc0E,OAAd,CAAsBrH,IAAtB,EAA4B;AACxBsH,MAAAA,SAAS,EAAE,IADa;AAExBT,MAAAA,UAAU,EAAE,IAFY;AAGxBU,MAAAA,aAAa,EAAE,IAHS;AAIxBC,MAAAA,OAAO,EAAE,IAJe;AAKxBC,MAAAA,iBAAiB,EAAE,KALK;AAMxBC,MAAAA,qBAAqB,EAAE;AANC,KAA5B;AAQA,SAAKnE,QAAL,CAAc6D,UAAd;AACAD,IAAAA,YAAY,CAAC,KAAKxF,GAAL,CAAS+B,KAAT,CAAeC,KAAf,CAAqB3D,IAArB,CAAD,CAAZ;AACA,SAAKgE,WAAL;AACH;;AACD2D,EAAAA,UAAU,GAAG;AACT,SAAKhF,QAAL,CAAcgF,UAAd;AACA,SAAK1D,KAAL,GAFS,CAGT;;AACA,SAAK5B,UAAL,CAAgB4B,KAAhB;AACA,SAAKjC,OAAL,CAAasB,MAAb,GAAsB,CAAtB;AACH;;AA/TyB","sourcesContent":["import { stars, hasOpenreplayAttribute } from \"../../utils.js\";\nimport { RemoveNodeAttribute, SetNodeAttribute, SetNodeAttributeURLBased, SetCSSDataURLBased, SetNodeData, CreateTextNode, CreateElementNode, MoveNode, RemoveNode, } from \"../../messages/index.js\";\nfunction isSVGElement(node) {\n    return node.namespaceURI === 'http://www.w3.org/2000/svg';\n}\n// TODO: we need a type expert here so we won't have to ignore the lines\n// TODO: use it everywhere (static function; export from which file? <-- global Window typing required)\nexport function isInstance(node, constr) {\n    const doc = node.ownerDocument;\n    if (!doc) { // null if Document\n        return constr.name === 'Document';\n    }\n    let context = \n    // @ts-ignore (for EI, Safary)\n    doc.parentWindow ||\n        doc.defaultView; // TODO: smart global typing for Window object\n    while (context.parent && context.parent !== context) {\n        // @ts-ignore\n        if (node instanceof context[constr.name]) {\n            return true;\n        }\n        // @ts-ignore\n        context = context.parent;\n    }\n    // @ts-ignore\n    return node instanceof context[constr.name];\n}\nfunction isIgnored(node) {\n    if (isInstance(node, Text)) {\n        return false;\n    }\n    if (!isInstance(node, Element)) {\n        return true;\n    }\n    const tag = node.tagName.toUpperCase();\n    if (tag === 'LINK') {\n        const rel = node.getAttribute('rel');\n        const as = node.getAttribute('as');\n        return !((rel === null || rel === void 0 ? void 0 : rel.includes('stylesheet')) || as === \"style\" || as === \"font\");\n    }\n    return (tag === 'SCRIPT' ||\n        tag === 'NOSCRIPT' ||\n        tag === 'META' ||\n        tag === 'TITLE' ||\n        tag === 'BASE');\n}\nfunction isRootNode(node) {\n    return isInstance(node, Document) || isInstance(node, ShadowRoot);\n}\nfunction isObservable(node) {\n    if (isRootNode(node)) {\n        return true;\n    }\n    return !isIgnored(node);\n}\nexport default class Observer {\n    constructor(app, options, context = window) {\n        this.app = app;\n        this.context = context;\n        this.commited = [];\n        this.recents = [];\n        this.myNodes = [];\n        this.indexes = [];\n        this.attributesList = [];\n        this.textSet = new Set();\n        this.textMasked = new Set();\n        this.options = Object.assign({\n            obscureTextEmails: true,\n            obscureTextNumbers: false,\n        }, options);\n        this.inUpperContext = context.parent === context;\n        this.observer = new MutationObserver(this.app.safe((mutations) => {\n            for (const mutation of mutations) {\n                const target = mutation.target;\n                const type = mutation.type;\n                // TODO TODO TODO: move to iframe_observer/remove??? (check if )\n                // Special case\n                // 'childList' on Document might happen in case of iframe. \n                // TODO: generalize as much as possible\n                // if (isInstance(target, Document) // Also ShadowRoot can be here\n                //     && type === 'childList' \n                //     //&& new Array(mutation.addedNodes).some(node => isInstance(node, HTMLHtmlElement))\n                // ) {\n                //   const parentFrame = target.defaultView?.frameElement\n                //   if (!parentFrame) { continue }\n                //   this.bindTree(target.documentElement)\n                //   const frameID = this.app.nodes.getID(parentFrame)\n                //   const docID = this.app.nodes.getID(target.documentElement)\n                //   if (frameID === undefined || docID === undefined) { continue }\n                //   this.app.send(CreateIFrameDocument(frameID, docID));\n                //   continue;\n                // }\n                if (!isObservable(target) || !context.document.contains(target)) {\n                    continue;\n                }\n                if (type === 'childList') {\n                    for (let i = 0; i < mutation.removedNodes.length; i++) {\n                        this.bindTree(mutation.removedNodes[i]);\n                    }\n                    for (let i = 0; i < mutation.addedNodes.length; i++) {\n                        this.bindTree(mutation.addedNodes[i]);\n                    }\n                    continue;\n                }\n                const id = this.app.nodes.getID(target);\n                if (id === undefined) {\n                    continue;\n                }\n                if (id >= this.recents.length) { // TODO: something more convinient\n                    this.recents[id] = undefined;\n                }\n                if (type === 'attributes') {\n                    const name = mutation.attributeName;\n                    if (name === null) {\n                        continue;\n                    }\n                    let attr = this.attributesList[id];\n                    if (attr === undefined) {\n                        this.attributesList[id] = attr = new Set();\n                    }\n                    attr.add(name);\n                    continue;\n                }\n                if (type === 'characterData') {\n                    this.textSet.add(id);\n                    continue;\n                }\n            }\n            this.commitNodes();\n        }));\n    }\n    clear() {\n        this.commited.length = 0;\n        this.recents.length = 0;\n        this.indexes.length = 1;\n        this.attributesList.length = 0;\n        this.textSet.clear();\n        //this.textMasked.clear();\n    }\n    sendNodeAttribute(id, node, name, value) {\n        if (isSVGElement(node)) {\n            if (name.substr(0, 6) === 'xlink:') {\n                name = name.substr(6);\n            }\n            if (value === null) {\n                this.app.send(new RemoveNodeAttribute(id, name));\n            }\n            else if (name === 'href') {\n                if (value.length > 1e5) {\n                    value = '';\n                }\n                this.app.send(new SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));\n            }\n            else {\n                this.app.send(new SetNodeAttribute(id, name, value));\n            }\n            return;\n        }\n        if (name === 'src' ||\n            name === 'srcset' ||\n            name === 'integrity' ||\n            name === 'crossorigin' ||\n            name === 'autocomplete' ||\n            name.substr(0, 2) === 'on') {\n            return;\n        }\n        if (name === 'value' &&\n            isInstance(node, HTMLInputElement) &&\n            node.type !== 'button' &&\n            node.type !== 'reset' &&\n            node.type !== 'submit') {\n            return;\n        }\n        if (value === null) {\n            this.app.send(new RemoveNodeAttribute(id, name));\n            return;\n        }\n        if (name === 'style' || name === 'href' && isInstance(node, HTMLLinkElement)) {\n            this.app.send(new SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));\n            return;\n        }\n        if (name === 'href' || value.length > 1e5) {\n            value = '';\n        }\n        this.app.send(new SetNodeAttribute(id, name, value));\n    }\n    /* TODO:  abstract sanitation */\n    getInnerTextSecure(el) {\n        const id = this.app.nodes.getID(el);\n        if (!id) {\n            return '';\n        }\n        return this.checkObscure(id, el.innerText);\n    }\n    checkObscure(id, data) {\n        if (this.textMasked.has(id)) {\n            return data.replace(/[^\\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]/g, '█');\n        }\n        if (this.options.obscureTextNumbers) {\n            data = data.replace(/\\d/g, '0');\n        }\n        if (this.options.obscureTextEmails) {\n            data = data.replace(/([^\\s]+)@([^\\s]+)\\.([^\\s]+)/g, (...f) => stars(f[1]) + '@' + stars(f[2]) + '.' + stars(f[3]));\n        }\n        return data;\n    }\n    sendNodeData(id, parentElement, data) {\n        if (isInstance(parentElement, HTMLStyleElement) || isInstance(parentElement, SVGStyleElement)) {\n            this.app.send(new SetCSSDataURLBased(id, data, this.app.getBaseHref()));\n            return;\n        }\n        data = this.checkObscure(id, data);\n        this.app.send(new SetNodeData(id, data));\n    }\n    /* end TODO:  abstract sanitation */\n    bindNode(node) {\n        const r = this.app.nodes.registerNode(node);\n        const id = r[0];\n        this.recents[id] = r[1] || this.recents[id] || false;\n        this.myNodes[id] = true;\n    }\n    bindTree(node) {\n        if (!isObservable(node)) {\n            return;\n        }\n        this.bindNode(node);\n        const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {\n            acceptNode: (node) => isIgnored(node) || this.app.nodes.getID(node) !== undefined\n                ? NodeFilter.FILTER_REJECT\n                : NodeFilter.FILTER_ACCEPT,\n        }, \n        // @ts-ignore\n        false);\n        while (walker.nextNode()) {\n            this.bindNode(walker.currentNode);\n        }\n    }\n    unbindNode(node) {\n        const id = this.app.nodes.unregisterNode(node);\n        if (id !== undefined && this.recents[id] === false) {\n            this.app.send(new RemoveNode(id));\n        }\n    }\n    _commitNode(id, node) {\n        if (isRootNode(node)) {\n            return true;\n        }\n        const parent = node.parentNode;\n        let parentID;\n        // Disable parent check for the upper context HTMLHtmlElement, because it is root there... (before)\n        // TODO: get rid of \"special\" cases (there is an issue with CreateDocument altered behaviour though)\n        // TODO: Clean the logic (though now it workd fine) \n        if (!isInstance(node, HTMLHtmlElement) || !this.inUpperContext) {\n            if (parent === null) {\n                this.unbindNode(node);\n                return false;\n            }\n            parentID = this.app.nodes.getID(parent);\n            if (parentID === undefined) {\n                this.unbindNode(node);\n                return false;\n            }\n            if (!this.commitNode(parentID)) {\n                this.unbindNode(node);\n                return false;\n            }\n            if (this.textMasked.has(parentID) ||\n                (isInstance(node, Element) && hasOpenreplayAttribute(node, 'masked'))) {\n                this.textMasked.add(id);\n            }\n        }\n        let sibling = node.previousSibling;\n        while (sibling !== null) {\n            const siblingID = this.app.nodes.getID(sibling);\n            if (siblingID !== undefined) {\n                this.commitNode(siblingID);\n                this.indexes[id] = this.indexes[siblingID] + 1;\n                break;\n            }\n            sibling = sibling.previousSibling;\n        }\n        if (sibling === null) {\n            this.indexes[id] = 0; //\n        }\n        const isNew = this.recents[id];\n        const index = this.indexes[id];\n        if (index === undefined) {\n            throw 'commitNode: missing node index';\n        }\n        if (isNew === true) {\n            if (isInstance(node, Element)) {\n                if (parentID !== undefined) {\n                    this.app.send(new CreateElementNode(id, parentID, index, node.tagName, isSVGElement(node)));\n                }\n                for (let i = 0; i < node.attributes.length; i++) {\n                    const attr = node.attributes[i];\n                    this.sendNodeAttribute(id, node, attr.nodeName, attr.value);\n                }\n            }\n            else if (isInstance(node, Text)) {\n                // for text node id != 0, hence parentID !== undefined and parent is Element\n                this.app.send(new CreateTextNode(id, parentID, index));\n                this.sendNodeData(id, parent, node.data);\n            }\n            return true;\n        }\n        if (isNew === false && parentID !== undefined) {\n            this.app.send(new MoveNode(id, parentID, index));\n        }\n        const attr = this.attributesList[id];\n        if (attr !== undefined) {\n            if (!isInstance(node, Element)) {\n                throw 'commitNode: node is not an element';\n            }\n            for (const name of attr) {\n                this.sendNodeAttribute(id, node, name, node.getAttribute(name));\n            }\n        }\n        if (this.textSet.has(id)) {\n            if (!isInstance(node, Text)) {\n                throw 'commitNode: node is not a text';\n            }\n            // for text node id != 0, hence parent is Element\n            this.sendNodeData(id, parent, node.data);\n        }\n        return true;\n    }\n    commitNode(id) {\n        const node = this.app.nodes.getNode(id);\n        if (node === undefined) {\n            return false;\n        }\n        const cmt = this.commited[id];\n        if (cmt !== undefined) {\n            return cmt;\n        }\n        return (this.commited[id] = this._commitNode(id, node));\n    }\n    commitNodes() {\n        let node;\n        for (let id = 0; id < this.recents.length; id++) {\n            // TODO: make things/logic nice here.\n            // commit required in any case if recents[id] true or false (in case of unbinding).\n            // ???!?!?R@TW:$HKJ$WLKn\n            if (!this.myNodes[id]) {\n                continue;\n            }\n            this.commitNode(id);\n            if (this.recents[id] === true && (node = this.app.nodes.getNode(id))) {\n                this.app.nodes.callNodeCallbacks(node);\n            }\n        }\n        this.clear();\n    }\n    // ISSSUE\n    observeRoot(node, beforeCommit, nodeToBind = node) {\n        this.observer.observe(node, {\n            childList: true,\n            attributes: true,\n            characterData: true,\n            subtree: true,\n            attributeOldValue: false,\n            characterDataOldValue: false,\n        });\n        this.bindTree(nodeToBind);\n        beforeCommit(this.app.nodes.getID(node));\n        this.commitNodes();\n    }\n    disconnect() {\n        this.observer.disconnect();\n        this.clear();\n        // to sanitizer\n        this.textMasked.clear();\n        this.myNodes.length = 0;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}