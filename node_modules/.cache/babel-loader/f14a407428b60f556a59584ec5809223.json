{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar react = require('react');\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar SUSPENSE_PROMISE = Symbol();\n\nvar isSuspensePromise = function isSuspensePromise(promise) {\n  return !!promise[SUSPENSE_PROMISE];\n};\n\nvar isSuspensePromiseAlreadyCancelled = function isSuspensePromiseAlreadyCancelled(suspensePromise) {\n  return !suspensePromise[SUSPENSE_PROMISE].c;\n};\n\nvar cancelSuspensePromise = function cancelSuspensePromise(suspensePromise) {\n  var _suspensePromise$SUSP, _suspensePromise$SUSP2;\n\n  (_suspensePromise$SUSP = (_suspensePromise$SUSP2 = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _suspensePromise$SUSP.call(_suspensePromise$SUSP2);\n};\n\nvar isEqualSuspensePromise = function isEqualSuspensePromise(oldSuspensePromise, newSuspensePromise) {\n  var oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  var newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\n\nvar createSuspensePromise = function createSuspensePromise(promise) {\n  var objectToAttach = {\n    o: promise,\n    c: null\n  };\n  var suspensePromise = new Promise(function (resolve) {\n    objectToAttach.c = function () {\n      objectToAttach.c = null;\n      resolve();\n    };\n\n    promise.then(objectToAttach.c, objectToAttach.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;\n  return suspensePromise;\n};\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\n\nvar READ_ATOM = 'r';\nvar WRITE_ATOM = 'w';\nvar COMMIT_ATOM = 'c';\nvar SUBSCRIBE_ATOM = 's';\nvar RESTORE_ATOMS = 'h';\nvar DEV_SUBSCRIBE_STATE = 'n';\nvar DEV_GET_MOUNTED_ATOMS = 'l';\nvar DEV_GET_ATOM_STATE = 'a';\nvar DEV_GET_MOUNTED = 'm';\n\nvar createStore = function createStore(initialValues) {\n  var _ref4;\n\n  var committedAtomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n  var stateListeners;\n  var mountedAtoms;\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n\n  if (initialValues) {\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          atom = _step$value[0],\n          value = _step$value[1];\n      var atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n\n        if (!hasInitialValue(atom)) {\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\n        }\n      }\n\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n\n  var suspensePromiseCacheMap = new WeakMap();\n\n  var addSuspensePromiseToCache = function addSuspensePromiseToCache(version, atom, suspensePromise) {\n    var cache = suspensePromiseCacheMap.get(atom);\n\n    if (!cache) {\n      cache = new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n\n    suspensePromise.then(function () {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n\n  var cancelAllSuspensePromiseInCache = function cancelAllSuspensePromiseInCache(atom) {\n    var versionSet = new Set();\n    var cache = suspensePromiseCacheMap.get(atom);\n\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach(function (suspensePromise, version) {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n\n    return versionSet;\n  };\n\n  var versionedAtomStateMapMap = new WeakMap();\n\n  var getVersionedAtomStateMap = function getVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n\n    return versionedAtomStateMap;\n  };\n\n  var getAtomState = function getAtomState(version, atom) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n\n      var _atomState = versionedAtomStateMap.get(atom);\n\n      if (!_atomState) {\n        _atomState = getAtomState(version.p, atom);\n\n        if (_atomState) {\n          if ('p' in _atomState) {\n            _atomState.p.then(function () {\n              return versionedAtomStateMap.delete(atom);\n            });\n          }\n\n          versionedAtomStateMap.set(atom, _atomState);\n        }\n      }\n\n      return _atomState;\n    }\n\n    return committedAtomStateMap.get(atom);\n  };\n\n  var setAtomState = function setAtomState(version, atom, atomState) {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      Object.freeze(atomState);\n    }\n\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      var prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n\n  var createReadDependencies = function createReadDependencies(version, prevReadDependencies, dependencies) {\n    if (prevReadDependencies === void 0) {\n      prevReadDependencies = new Map();\n    }\n\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n\n    var readDependencies = new Map();\n    var changed = false;\n    dependencies.forEach(function (atom) {\n      var _getAtomState;\n\n      var revision = ((_getAtomState = getAtomState(version, atom)) == null ? void 0 : _getAtomState.r) || 0;\n      readDependencies.set(atom, revision);\n\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n\n    return readDependencies;\n  };\n\n  var setAtomValue = function setAtomValue(version, atom, value, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      if (suspensePromise && (!('p' in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n\n      if ('p' in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n\n    var nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n\n    if (!atomState || !('v' in atomState) || !Object.is(atomState.v, value)) {\n      ++nextAtomState.r;\n\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    }\n\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomReadError = function setAtomReadError(version, atom, error, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      if (suspensePromise && (!('p' in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n\n      if ('p' in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n\n    var nextAtomState = {\n      e: error,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomSuspensePromise = function setAtomSuspensePromise(version, atom, suspensePromise, dependencies) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState && 'p' in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        return atomState;\n      }\n\n      cancelSuspensePromise(atomState.p);\n    }\n\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    var nextAtomState = {\n      p: suspensePromise,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomPromiseOrValue = function setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies) {\n    if (promiseOrValue instanceof Promise) {\n      var suspensePromise = createSuspensePromise(promiseOrValue.then(function (value) {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n        flushPending(version);\n      }).catch(function (e) {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e) && isSuspensePromiseAlreadyCancelled(e)) {\n            e.then(function () {\n              return readAtomState(version, atom, true);\n            });\n          }\n\n          return e;\n        }\n\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        flushPending(version);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n\n  var setAtomInvalidated = function setAtomInvalidated(version, atom) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      var nextAtomState = _extends({}, atomState, {\n        i: atomState.r\n      });\n\n      setAtomState(version, atom, nextAtomState);\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not invalidate non existing atom', atom);\n    }\n  };\n\n  var readAtomState = function readAtomState(version, atom, force) {\n    if (!force) {\n      var _atomState2 = getAtomState(version, atom);\n\n      if (_atomState2) {\n        _atomState2.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              var aState = getAtomState(version, a);\n\n              if (aState && aState.r === aState.i) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n\n        if (Array.from(_atomState2.d.entries()).every(function (_ref) {\n          var a = _ref[0],\n              r = _ref[1];\n          var aState = getAtomState(version, a);\n          return aState && !('e' in aState) && !('p' in aState) && aState.r === r;\n        })) {\n          return _atomState2;\n        }\n      }\n    }\n\n    var dependencies = new Set();\n\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n\n        if (aState) {\n          if ('e' in aState) {\n            throw aState.e;\n          }\n\n          if ('p' in aState) {\n            throw aState.p;\n          }\n\n          return aState.v;\n        }\n\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        throw new Error('no atom init');\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        var suspensePromise = createSuspensePromise(errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n\n  var readAtom = function readAtom(readingAtom, version) {\n    var atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n\n  var addAtom = function addAtom(addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n\n    return mounted;\n  };\n\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n\n  var delAtom = function delAtom(deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n\n  var invalidateDependents = function invalidateDependents(version, atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(function (dependent) {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n\n  var writeAtomState = function writeAtomState(version, atom, update) {\n    var isSync = true;\n\n    var writeGetter = function writeGetter(a, options) {\n      if (typeof options === 'boolean') {\n        console.warn('[DEPRECATED] Please use { unstable_promise: true }');\n        options = {\n          unstable_promise: options\n        };\n      }\n\n      var aState = readAtomState(version, a);\n\n      if ('e' in aState) {\n        throw aState.e;\n      }\n\n      if ('p' in aState) {\n        var _options;\n\n        if ((_options = options) != null && _options.unstable_promise) {\n          return aState.p.then(function () {\n            return writeGetter(a, options);\n          });\n        }\n\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          console.info('Reading pending atom state in write operation. We throw a promise for now.', a);\n        }\n\n        throw aState.p;\n      }\n\n      if ('v' in aState) {\n        return aState.v;\n      }\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\n      }\n\n      throw new Error('no value found');\n    };\n\n    var setter = function setter(a, v) {\n      var promiseOrVoid;\n\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('atom not writable');\n        }\n\n        var versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach(function (cancelledVersion) {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        setAtomPromiseOrValue(version, a, v);\n        invalidateDependents(version, a);\n      } else {\n        promiseOrVoid = writeAtomState(version, a, v);\n      }\n\n      if (!isSync) {\n        flushPending(version);\n      }\n\n      return promiseOrVoid;\n    };\n\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    version = undefined;\n    return promiseOrVoid;\n  };\n\n  var writeAtom = function writeAtom(writingAtom, update, version) {\n    var promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: new Set()\n    };\n    mountedMap.set(atom, mounted);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.add(atom);\n    }\n\n    var atomState = readAtomState(undefined, atom);\n    atomState.d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update);\n      };\n\n      var onUnmount = atom.onMount(setAtom);\n\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n\n    return mounted;\n  };\n\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get;\n\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n\n    if (onUnmount) {\n      onUnmount();\n    }\n\n    mountedMap.delete(atom);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.delete(atom);\n    }\n\n    var atomState = getAtomState(undefined, atom);\n\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n\n          if (mounted) {\n            mounted.t.delete(atom);\n\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n\n  var mountDependencies = function mountDependencies(atom, atomState, prevReadDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.t.delete(atom);\n\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.t.add(atom);\n      } else {\n        mountAtom(a, atom);\n      }\n    });\n  };\n\n  var flushPending = function flushPending(version) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach(function (atomState, atom) {\n        if (atomState !== committedAtomStateMap.get(atom)) {\n          var mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n            return listener(version);\n          });\n        }\n      });\n      return;\n    }\n\n    var pending = Array.from(pendingMap);\n    pendingMap.clear();\n    pending.forEach(function (_ref2) {\n      var atom = _ref2[0],\n          prevAtomState = _ref2[1];\n      var atomState = getAtomState(undefined, atom);\n\n      if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n      }\n\n      var mounted = mountedMap.get(atom);\n      mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n        return listener();\n      });\n    });\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      stateListeners.forEach(function (l) {\n        return l();\n      });\n    }\n  };\n\n  var commitVersionedAtomStateMap = function commitVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach(function (atomState, atom) {\n      var prevAtomState = committedAtomStateMap.get(atom);\n\n      if (atomState.r > ((prevAtomState == null ? void 0 : prevAtomState.r) || 0) || 'v' in atomState && atomState.r === (prevAtomState == null ? void 0 : prevAtomState.r) && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        committedAtomStateMap.set(atom, atomState);\n\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n\n  var commitAtom = function commitAtom(_atom, version) {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n\n    flushPending(undefined);\n  };\n\n  var subscribeAtom = function subscribeAtom(atom, callback) {\n    var mounted = addAtom(atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n\n  var restoreAtoms = function restoreAtoms(values, version) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n          _atom2 = _step2$value[0],\n          _value = _step2$value[1];\n\n      if (hasInitialValue(_atom2)) {\n        setAtomPromiseOrValue(version, _atom2, _value);\n        invalidateDependents(version, _atom2);\n      }\n    }\n\n    flushPending(version);\n  };\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    var _ref3;\n\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[COMMIT_ATOM] = commitAtom, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_SUBSCRIBE_STATE] = function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }, _ref3[DEV_GET_MOUNTED_ATOMS] = function () {\n      return mountedAtoms.values();\n    }, _ref3[DEV_GET_ATOM_STATE] = function (a) {\n      return committedAtomStateMap.get(a);\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\n      return mountedMap.get(a);\n    }, _ref3;\n  }\n\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[COMMIT_ATOM] = commitAtom, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\n};\n\nvar createScopeContainer = function createScopeContainer(initialValues) {\n  var store = createStore(initialValues);\n  return {\n    s: store\n  };\n};\n\nvar ScopeContextMap = new Map();\n\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\n  }\n\n  return ScopeContextMap.get(scope);\n};\n\nvar Provider = function Provider(_ref) {\n  var children = _ref.children,\n      initialValues = _ref.initialValues,\n      scope = _ref.scope,\n      unstable_enableVersionedWrite = _ref.unstable_enableVersionedWrite;\n\n  var _useState = react.useState(),\n      version = _useState[0],\n      setVersion = _useState[1];\n\n  react.useEffect(function () {\n    if (version) {\n      scopeContainerRef.current.s[COMMIT_ATOM](null, version);\n      delete version.p;\n    }\n  }, [version]);\n  var scopeContainerRef = react.useRef();\n\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues);\n\n    if (unstable_enableVersionedWrite) {\n      scopeContainerRef.current.w = function (write) {\n        setVersion(function (parentVersion) {\n          var nextVersion = parentVersion ? {\n            p: parentVersion\n          } : {};\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n    }\n  }\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\n    useDebugState(scopeContainerRef.current);\n  }\n\n  var ScopeContainerContext = getScopeContext(scope);\n  return react.createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nvar atomToPrintable = function atomToPrintable(atom) {\n  return atom.debugLabel || atom.toString();\n};\n\nvar stateToPrintable = function stateToPrintable(_ref2) {\n  var store = _ref2[0],\n      atoms = _ref2[1];\n  return Object.fromEntries(atoms.flatMap(function (atom) {\n    var _store$DEV_GET_MOUNTE, _store$DEV_GET_ATOM_S;\n\n    var mounted = (_store$DEV_GET_MOUNTE = store[DEV_GET_MOUNTED]) == null ? void 0 : _store$DEV_GET_MOUNTE.call(store, atom);\n\n    if (!mounted) {\n      return [];\n    }\n\n    var dependents = mounted.t;\n    var atomState = ((_store$DEV_GET_ATOM_S = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _store$DEV_GET_ATOM_S.call(store, atom)) || {};\n    return [[atomToPrintable(atom), _extends({}, 'e' in atomState && {\n      error: atomState.e\n    }, 'p' in atomState && {\n      promise: atomState.p\n    }, 'v' in atomState && {\n      value: atomState.v\n    }, {\n      dependents: Array.from(dependents).map(atomToPrintable)\n    })]];\n  }));\n};\n\nvar useDebugState = function useDebugState(scopeContainer) {\n  var store = scopeContainer.s;\n\n  var _useState2 = react.useState([]),\n      atoms = _useState2[0],\n      setAtoms = _useState2[1];\n\n  react.useEffect(function () {\n    var _store$DEV_SUBSCRIBE_;\n\n    var callback = function callback() {\n      var _store$DEV_GET_MOUNTE2;\n\n      setAtoms(Array.from(((_store$DEV_GET_MOUNTE2 = store[DEV_GET_MOUNTED_ATOMS]) == null ? void 0 : _store$DEV_GET_MOUNTE2.call(store)) || []));\n    };\n\n    var unsubscribe = (_store$DEV_SUBSCRIBE_ = store[DEV_SUBSCRIBE_STATE]) == null ? void 0 : _store$DEV_SUBSCRIBE_.call(store, callback);\n    callback();\n    return unsubscribe;\n  }, [store]);\n  react.useDebugValue([store, atoms], stateToPrintable);\n};\n\nvar keyCount = 0;\n\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = function (get) {\n      return get(config);\n    };\n\n    config.write = function (get, set, update) {\n      return set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nvar isWritable = function isWritable(atom) {\n  return !!atom.write;\n};\n\nfunction useAtom(atom, scope) {\n  if ('scope' in atom) {\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\n    scope = atom.scope;\n  }\n\n  var ScopeContext = getScopeContext(scope);\n\n  var _useContext = react.useContext(ScopeContext),\n      store = _useContext.s,\n      versionedWrite = _useContext.w;\n\n  var getAtomValue = react.useCallback(function (version) {\n    var atomState = store[READ_ATOM](atom, version);\n\n    if ('e' in atomState) {\n      throw atomState.e;\n    }\n\n    if ('p' in atomState) {\n      throw atomState.p;\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [store, atom]);\n\n  var _useReducer = react.useReducer(react.useCallback(function (prev, nextVersion) {\n    var nextValue = getAtomValue(nextVersion);\n\n    if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n      return prev;\n    }\n\n    return [nextVersion, nextValue, atom];\n  }, [getAtomValue, atom]), undefined, function () {\n    var initialVersion = undefined;\n    var initialValue = getAtomValue(initialVersion);\n    return [initialVersion, initialValue, atom];\n  }),\n      _useReducer$ = _useReducer[0],\n      version = _useReducer$[0],\n      value = _useReducer$[1],\n      atomFromUseReducer = _useReducer$[2],\n      dispatch = _useReducer[1];\n\n  if (atomFromUseReducer !== atom) {\n    dispatch(undefined);\n  }\n\n  react.useEffect(function () {\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, dispatch);\n    dispatch(undefined);\n    return unsubscribe;\n  }, [store, atom]);\n  react.useEffect(function () {\n    store[COMMIT_ATOM](atom, version);\n  });\n  var setAtom = react.useCallback(function (update) {\n    if (isWritable(atom)) {\n      var write = function write(version) {\n        return store[WRITE_ATOM](atom, update, version);\n      };\n\n      return versionedWrite ? versionedWrite(write) : write();\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [store, versionedWrite, atom]);\n  react.useDebugValue(value);\n  return [value, setAtom];\n}\n\nexports.Provider = Provider;\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\nexports.atom = atom;\nexports.useAtom = useAtom;","map":{"version":3,"sources":["/Users/kushthakker/Downloads/imagecompare-both/node_modules/jotai/index.js"],"names":["Object","defineProperty","exports","value","react","require","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","toString","slice","constructor","name","Array","from","test","arr","len","arr2","_createForOfIteratorHelperLoose","allowArrayLike","it","Symbol","iterator","next","bind","isArray","done","TypeError","SUSPENSE_PROMISE","isSuspensePromise","promise","isSuspensePromiseAlreadyCancelled","suspensePromise","c","cancelSuspensePromise","_suspensePromise$SUSP","_suspensePromise$SUSP2","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","newOriginalPromise","createSuspensePromise","objectToAttach","Promise","resolve","then","hasInitialValue","atom","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","_ref4","committedAtomStateMap","WeakMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","process","env","NODE_ENV","Set","_iterator","_step","_step$value","atomState","v","r","d","freeze","console","warn","set","suspensePromiseCacheMap","addSuspensePromiseToCache","version","cache","get","delete","size","cancelAllSuspensePromiseInCache","versionSet","forEach","add","versionedAtomStateMapMap","getVersionedAtomStateMap","versionedAtomStateMap","getAtomState","_atomState","p","setAtomState","prevAtomState","has","createReadDependencies","prevReadDependencies","dependencies","readDependencies","changed","_getAtomState","revision","setAtomValue","nextAtomState","is","setAtomReadError","error","e","setAtomSuspensePromise","setAtomPromiseOrValue","promiseOrValue","flushPending","catch","readAtomState","setAtomInvalidated","force","_atomState2","_","a","aState","entries","every","_ref","read","init","Error","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","isSync","writeGetter","options","unstable_promise","_options","info","setter","promiseOrVoid","cancelledVersion","write","undefined","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","onMount","setAtom","onUnmount","u","_mountedMap$get","mountDependencies","keys","listener","pending","clear","_ref2","commitVersionedAtomStateMap","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","_iterator2","_step2","_step2$value","_atom2","_value","_ref3","createScopeContainer","store","s","ScopeContextMap","getScopeContext","scope","createContext","Provider","children","unstable_enableVersionedWrite","_useState","useState","setVersion","useEffect","scopeContainerRef","current","useRef","w","parentVersion","nextVersion","useDebugState","ScopeContainerContext","createElement","atomToPrintable","debugLabel","stateToPrintable","atoms","fromEntries","flatMap","_store$DEV_GET_MOUNTE","_store$DEV_GET_ATOM_S","dependents","map","scopeContainer","_useState2","setAtoms","_store$DEV_SUBSCRIBE_","_store$DEV_GET_MOUNTE2","unsubscribe","useDebugValue","keyCount","config","isWritable","useAtom","ScopeContext","_useContext","useContext","versionedWrite","getAtomValue","useCallback","_useReducer","useReducer","prev","nextValue","initialVersion","initialValue","_useReducer$","atomFromUseReducer","dispatch","SECRET_INTERNAL_getScopeContext"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar react = require('react');\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar SUSPENSE_PROMISE = Symbol();\nvar isSuspensePromise = function isSuspensePromise(promise) {\n  return !!promise[SUSPENSE_PROMISE];\n};\nvar isSuspensePromiseAlreadyCancelled = function isSuspensePromiseAlreadyCancelled(suspensePromise) {\n  return !suspensePromise[SUSPENSE_PROMISE].c;\n};\nvar cancelSuspensePromise = function cancelSuspensePromise(suspensePromise) {\n  var _suspensePromise$SUSP, _suspensePromise$SUSP2;\n\n  (_suspensePromise$SUSP = (_suspensePromise$SUSP2 = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _suspensePromise$SUSP.call(_suspensePromise$SUSP2);\n};\nvar isEqualSuspensePromise = function isEqualSuspensePromise(oldSuspensePromise, newSuspensePromise) {\n  var oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  var newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nvar createSuspensePromise = function createSuspensePromise(promise) {\n  var objectToAttach = {\n    o: promise,\n    c: null\n  };\n  var suspensePromise = new Promise(function (resolve) {\n    objectToAttach.c = function () {\n      objectToAttach.c = null;\n      resolve();\n    };\n\n    promise.then(objectToAttach.c, objectToAttach.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;\n  return suspensePromise;\n};\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\n\nvar READ_ATOM = 'r';\nvar WRITE_ATOM = 'w';\nvar COMMIT_ATOM = 'c';\nvar SUBSCRIBE_ATOM = 's';\nvar RESTORE_ATOMS = 'h';\nvar DEV_SUBSCRIBE_STATE = 'n';\nvar DEV_GET_MOUNTED_ATOMS = 'l';\nvar DEV_GET_ATOM_STATE = 'a';\nvar DEV_GET_MOUNTED = 'm';\nvar createStore = function createStore(initialValues) {\n  var _ref4;\n\n  var committedAtomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n  var stateListeners;\n  var mountedAtoms;\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n\n  if (initialValues) {\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          atom = _step$value[0],\n          value = _step$value[1];\n      var atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n\n        if (!hasInitialValue(atom)) {\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\n        }\n      }\n\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n\n  var suspensePromiseCacheMap = new WeakMap();\n\n  var addSuspensePromiseToCache = function addSuspensePromiseToCache(version, atom, suspensePromise) {\n    var cache = suspensePromiseCacheMap.get(atom);\n\n    if (!cache) {\n      cache = new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n\n    suspensePromise.then(function () {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n\n  var cancelAllSuspensePromiseInCache = function cancelAllSuspensePromiseInCache(atom) {\n    var versionSet = new Set();\n    var cache = suspensePromiseCacheMap.get(atom);\n\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach(function (suspensePromise, version) {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n\n    return versionSet;\n  };\n\n  var versionedAtomStateMapMap = new WeakMap();\n\n  var getVersionedAtomStateMap = function getVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n\n    return versionedAtomStateMap;\n  };\n\n  var getAtomState = function getAtomState(version, atom) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n\n      var _atomState = versionedAtomStateMap.get(atom);\n\n      if (!_atomState) {\n        _atomState = getAtomState(version.p, atom);\n\n        if (_atomState) {\n          if ('p' in _atomState) {\n            _atomState.p.then(function () {\n              return versionedAtomStateMap.delete(atom);\n            });\n          }\n\n          versionedAtomStateMap.set(atom, _atomState);\n        }\n      }\n\n      return _atomState;\n    }\n\n    return committedAtomStateMap.get(atom);\n  };\n\n  var setAtomState = function setAtomState(version, atom, atomState) {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      Object.freeze(atomState);\n    }\n\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      var prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n\n  var createReadDependencies = function createReadDependencies(version, prevReadDependencies, dependencies) {\n    if (prevReadDependencies === void 0) {\n      prevReadDependencies = new Map();\n    }\n\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n\n    var readDependencies = new Map();\n    var changed = false;\n    dependencies.forEach(function (atom) {\n      var _getAtomState;\n\n      var revision = ((_getAtomState = getAtomState(version, atom)) == null ? void 0 : _getAtomState.r) || 0;\n      readDependencies.set(atom, revision);\n\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n\n    return readDependencies;\n  };\n\n  var setAtomValue = function setAtomValue(version, atom, value, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      if (suspensePromise && (!('p' in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n\n      if ('p' in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n\n    var nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n\n    if (!atomState || !('v' in atomState) || !Object.is(atomState.v, value)) {\n      ++nextAtomState.r;\n\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    }\n\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomReadError = function setAtomReadError(version, atom, error, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      if (suspensePromise && (!('p' in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n\n      if ('p' in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n\n    var nextAtomState = {\n      e: error,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomSuspensePromise = function setAtomSuspensePromise(version, atom, suspensePromise, dependencies) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState && 'p' in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        return atomState;\n      }\n\n      cancelSuspensePromise(atomState.p);\n    }\n\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    var nextAtomState = {\n      p: suspensePromise,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomPromiseOrValue = function setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies) {\n    if (promiseOrValue instanceof Promise) {\n      var suspensePromise = createSuspensePromise(promiseOrValue.then(function (value) {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n        flushPending(version);\n      }).catch(function (e) {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e) && isSuspensePromiseAlreadyCancelled(e)) {\n            e.then(function () {\n              return readAtomState(version, atom, true);\n            });\n          }\n\n          return e;\n        }\n\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        flushPending(version);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n\n  var setAtomInvalidated = function setAtomInvalidated(version, atom) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      var nextAtomState = _extends({}, atomState, {\n        i: atomState.r\n      });\n\n      setAtomState(version, atom, nextAtomState);\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not invalidate non existing atom', atom);\n    }\n  };\n\n  var readAtomState = function readAtomState(version, atom, force) {\n    if (!force) {\n      var _atomState2 = getAtomState(version, atom);\n\n      if (_atomState2) {\n        _atomState2.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              var aState = getAtomState(version, a);\n\n              if (aState && aState.r === aState.i) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n\n        if (Array.from(_atomState2.d.entries()).every(function (_ref) {\n          var a = _ref[0],\n              r = _ref[1];\n          var aState = getAtomState(version, a);\n          return aState && !('e' in aState) && !('p' in aState) && aState.r === r;\n        })) {\n          return _atomState2;\n        }\n      }\n    }\n\n    var dependencies = new Set();\n\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n\n        if (aState) {\n          if ('e' in aState) {\n            throw aState.e;\n          }\n\n          if ('p' in aState) {\n            throw aState.p;\n          }\n\n          return aState.v;\n        }\n\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        throw new Error('no atom init');\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        var suspensePromise = createSuspensePromise(errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n\n  var readAtom = function readAtom(readingAtom, version) {\n    var atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n\n  var addAtom = function addAtom(addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n\n    return mounted;\n  };\n\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n\n  var delAtom = function delAtom(deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n\n  var invalidateDependents = function invalidateDependents(version, atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(function (dependent) {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n\n  var writeAtomState = function writeAtomState(version, atom, update) {\n    var isSync = true;\n\n    var writeGetter = function writeGetter(a, options) {\n      if (typeof options === 'boolean') {\n        console.warn('[DEPRECATED] Please use { unstable_promise: true }');\n        options = {\n          unstable_promise: options\n        };\n      }\n\n      var aState = readAtomState(version, a);\n\n      if ('e' in aState) {\n        throw aState.e;\n      }\n\n      if ('p' in aState) {\n        var _options;\n\n        if ((_options = options) != null && _options.unstable_promise) {\n          return aState.p.then(function () {\n            return writeGetter(a, options);\n          });\n        }\n\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          console.info('Reading pending atom state in write operation. We throw a promise for now.', a);\n        }\n\n        throw aState.p;\n      }\n\n      if ('v' in aState) {\n        return aState.v;\n      }\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\n      }\n\n      throw new Error('no value found');\n    };\n\n    var setter = function setter(a, v) {\n      var promiseOrVoid;\n\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('atom not writable');\n        }\n\n        var versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach(function (cancelledVersion) {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        setAtomPromiseOrValue(version, a, v);\n        invalidateDependents(version, a);\n      } else {\n        promiseOrVoid = writeAtomState(version, a, v);\n      }\n\n      if (!isSync) {\n        flushPending(version);\n      }\n\n      return promiseOrVoid;\n    };\n\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    version = undefined;\n    return promiseOrVoid;\n  };\n\n  var writeAtom = function writeAtom(writingAtom, update, version) {\n    var promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: new Set()\n    };\n    mountedMap.set(atom, mounted);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.add(atom);\n    }\n\n    var atomState = readAtomState(undefined, atom);\n    atomState.d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update);\n      };\n\n      var onUnmount = atom.onMount(setAtom);\n\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n\n    return mounted;\n  };\n\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get;\n\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n\n    if (onUnmount) {\n      onUnmount();\n    }\n\n    mountedMap.delete(atom);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.delete(atom);\n    }\n\n    var atomState = getAtomState(undefined, atom);\n\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n\n          if (mounted) {\n            mounted.t.delete(atom);\n\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n\n  var mountDependencies = function mountDependencies(atom, atomState, prevReadDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.t.delete(atom);\n\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.t.add(atom);\n      } else {\n        mountAtom(a, atom);\n      }\n    });\n  };\n\n  var flushPending = function flushPending(version) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach(function (atomState, atom) {\n        if (atomState !== committedAtomStateMap.get(atom)) {\n          var mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n            return listener(version);\n          });\n        }\n      });\n      return;\n    }\n\n    var pending = Array.from(pendingMap);\n    pendingMap.clear();\n    pending.forEach(function (_ref2) {\n      var atom = _ref2[0],\n          prevAtomState = _ref2[1];\n      var atomState = getAtomState(undefined, atom);\n\n      if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n      }\n\n      var mounted = mountedMap.get(atom);\n      mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n        return listener();\n      });\n    });\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      stateListeners.forEach(function (l) {\n        return l();\n      });\n    }\n  };\n\n  var commitVersionedAtomStateMap = function commitVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach(function (atomState, atom) {\n      var prevAtomState = committedAtomStateMap.get(atom);\n\n      if (atomState.r > ((prevAtomState == null ? void 0 : prevAtomState.r) || 0) || 'v' in atomState && atomState.r === (prevAtomState == null ? void 0 : prevAtomState.r) && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        committedAtomStateMap.set(atom, atomState);\n\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n\n  var commitAtom = function commitAtom(_atom, version) {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n\n    flushPending(undefined);\n  };\n\n  var subscribeAtom = function subscribeAtom(atom, callback) {\n    var mounted = addAtom(atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n\n  var restoreAtoms = function restoreAtoms(values, version) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n          _atom2 = _step2$value[0],\n          _value = _step2$value[1];\n\n      if (hasInitialValue(_atom2)) {\n        setAtomPromiseOrValue(version, _atom2, _value);\n        invalidateDependents(version, _atom2);\n      }\n    }\n\n    flushPending(version);\n  };\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    var _ref3;\n\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[COMMIT_ATOM] = commitAtom, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_SUBSCRIBE_STATE] = function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }, _ref3[DEV_GET_MOUNTED_ATOMS] = function () {\n      return mountedAtoms.values();\n    }, _ref3[DEV_GET_ATOM_STATE] = function (a) {\n      return committedAtomStateMap.get(a);\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\n      return mountedMap.get(a);\n    }, _ref3;\n  }\n\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[COMMIT_ATOM] = commitAtom, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\n};\n\nvar createScopeContainer = function createScopeContainer(initialValues) {\n  var store = createStore(initialValues);\n  return {\n    s: store\n  };\n};\nvar ScopeContextMap = new Map();\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\n  }\n\n  return ScopeContextMap.get(scope);\n};\n\nvar Provider = function Provider(_ref) {\n  var children = _ref.children,\n      initialValues = _ref.initialValues,\n      scope = _ref.scope,\n      unstable_enableVersionedWrite = _ref.unstable_enableVersionedWrite;\n\n  var _useState = react.useState(),\n      version = _useState[0],\n      setVersion = _useState[1];\n\n  react.useEffect(function () {\n    if (version) {\n      scopeContainerRef.current.s[COMMIT_ATOM](null, version);\n      delete version.p;\n    }\n  }, [version]);\n  var scopeContainerRef = react.useRef();\n\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues);\n\n    if (unstable_enableVersionedWrite) {\n      scopeContainerRef.current.w = function (write) {\n        setVersion(function (parentVersion) {\n          var nextVersion = parentVersion ? {\n            p: parentVersion\n          } : {};\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n    }\n  }\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\n    useDebugState(scopeContainerRef.current);\n  }\n\n  var ScopeContainerContext = getScopeContext(scope);\n  return react.createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nvar atomToPrintable = function atomToPrintable(atom) {\n  return atom.debugLabel || atom.toString();\n};\n\nvar stateToPrintable = function stateToPrintable(_ref2) {\n  var store = _ref2[0],\n      atoms = _ref2[1];\n  return Object.fromEntries(atoms.flatMap(function (atom) {\n    var _store$DEV_GET_MOUNTE, _store$DEV_GET_ATOM_S;\n\n    var mounted = (_store$DEV_GET_MOUNTE = store[DEV_GET_MOUNTED]) == null ? void 0 : _store$DEV_GET_MOUNTE.call(store, atom);\n\n    if (!mounted) {\n      return [];\n    }\n\n    var dependents = mounted.t;\n    var atomState = ((_store$DEV_GET_ATOM_S = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _store$DEV_GET_ATOM_S.call(store, atom)) || {};\n    return [[atomToPrintable(atom), _extends({}, 'e' in atomState && {\n      error: atomState.e\n    }, 'p' in atomState && {\n      promise: atomState.p\n    }, 'v' in atomState && {\n      value: atomState.v\n    }, {\n      dependents: Array.from(dependents).map(atomToPrintable)\n    })]];\n  }));\n};\n\nvar useDebugState = function useDebugState(scopeContainer) {\n  var store = scopeContainer.s;\n\n  var _useState2 = react.useState([]),\n      atoms = _useState2[0],\n      setAtoms = _useState2[1];\n\n  react.useEffect(function () {\n    var _store$DEV_SUBSCRIBE_;\n\n    var callback = function callback() {\n      var _store$DEV_GET_MOUNTE2;\n\n      setAtoms(Array.from(((_store$DEV_GET_MOUNTE2 = store[DEV_GET_MOUNTED_ATOMS]) == null ? void 0 : _store$DEV_GET_MOUNTE2.call(store)) || []));\n    };\n\n    var unsubscribe = (_store$DEV_SUBSCRIBE_ = store[DEV_SUBSCRIBE_STATE]) == null ? void 0 : _store$DEV_SUBSCRIBE_.call(store, callback);\n    callback();\n    return unsubscribe;\n  }, [store]);\n  react.useDebugValue([store, atoms], stateToPrintable);\n};\n\nvar keyCount = 0;\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = function (get) {\n      return get(config);\n    };\n\n    config.write = function (get, set, update) {\n      return set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nvar isWritable = function isWritable(atom) {\n  return !!atom.write;\n};\n\nfunction useAtom(atom, scope) {\n  if ('scope' in atom) {\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\n    scope = atom.scope;\n  }\n\n  var ScopeContext = getScopeContext(scope);\n\n  var _useContext = react.useContext(ScopeContext),\n      store = _useContext.s,\n      versionedWrite = _useContext.w;\n\n  var getAtomValue = react.useCallback(function (version) {\n    var atomState = store[READ_ATOM](atom, version);\n\n    if ('e' in atomState) {\n      throw atomState.e;\n    }\n\n    if ('p' in atomState) {\n      throw atomState.p;\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [store, atom]);\n\n  var _useReducer = react.useReducer(react.useCallback(function (prev, nextVersion) {\n    var nextValue = getAtomValue(nextVersion);\n\n    if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n      return prev;\n    }\n\n    return [nextVersion, nextValue, atom];\n  }, [getAtomValue, atom]), undefined, function () {\n    var initialVersion = undefined;\n    var initialValue = getAtomValue(initialVersion);\n    return [initialVersion, initialValue, atom];\n  }),\n      _useReducer$ = _useReducer[0],\n      version = _useReducer$[0],\n      value = _useReducer$[1],\n      atomFromUseReducer = _useReducer$[2],\n      dispatch = _useReducer[1];\n\n  if (atomFromUseReducer !== atom) {\n    dispatch(undefined);\n  }\n\n  react.useEffect(function () {\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, dispatch);\n    dispatch(undefined);\n    return unsubscribe;\n  }, [store, atom]);\n  react.useEffect(function () {\n    store[COMMIT_ATOM](atom, version);\n  });\n  var setAtom = react.useCallback(function (update) {\n    if (isWritable(atom)) {\n      var write = function write(version) {\n        return store[WRITE_ATOM](atom, update, version);\n      };\n\n      return versionedWrite ? versionedWrite(write) : write();\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [store, versionedWrite, atom]);\n  react.useDebugValue(value);\n  return [value, setAtom];\n}\n\nexports.Provider = Provider;\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\nexports.atom = atom;\nexports.useAtom = useAtom;\n"]},"metadata":{},"sourceType":"script"}